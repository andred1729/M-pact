<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Globe Simulator</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="./node_modules/cesium/Build/Cesium/Widgets/widgets.css" />

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bitcount+Single+Ink:wght@100..900&display=swap" rel="stylesheet">

    <style>

      
      :root { color-scheme: dark; font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; }
      body { margin: 0; background: #0b1a2a; color: #f1f3f5; overflow: hidden; }
      #cesiumContainer { position: absolute; inset: 0; }
      .overlay {
        position: absolute; top: 1.5rem; left: 1.5rem; display: flex; flex-direction: column; gap: 0.5rem; z-index: 10;
        background: rgba(6,17,32,.8); border: 1px solid rgba(110,191,244,.35); border-radius: .75rem; padding: 1rem 1.25rem;
        max-width: 20rem; backdrop-filter: blur(6px); box-shadow: 0 12px 35px rgba(0,0,0,.35);
      }
      .overlay h1 { margin: 0; font-size: 1.8rem; color: #cf6de2; font-family: 'Bitcount Single Ink', sans-serif;}
      .overlay p { margin: 0; font-size: .95rem; line-height: 1.45; color: #c8d6e5; }
      .overlay button {
        margin-top: .75rem; padding: .5rem 1.1rem; font-size: .85rem; border: 1px solid rgba(125,211,252,.45); border-radius: 999px;
        background: linear-gradient(120deg,#1d8cf8,#935ade); color: #fff; cursor: pointer; transition: transform .2s, box-shadow .2s;
        box-shadow: 0 8px 22px rgba(33,150,243,.35);
      }
      .overlay button:hover:enabled { transform: translateY(-1px); box-shadow: 0 12px 28px rgba(33,150,243,.4); }
      .overlay button:disabled { opacity: .6; cursor: default; box-shadow: none; }
      .overlay button.small{ padding:.35rem .75rem; font-size:.8rem; }
      #cityView {
        background: linear-gradient(120deg,#4b5563,#1f2937);
        border-color: rgba(148,163,184,.45);
        box-shadow: none;
        color: #e5e7eb;
      }
      #cityView.btn-ready {
        background: linear-gradient(120deg,#1d8cf8,#935ade);
        border-color: rgba(125,211,252,.45);
        color: #fff;
        box-shadow: 0 8px 22px rgba(33,150,243,.35);
      }
      #cityView.btn-ready:hover:enabled {
        box-shadow: 0 12px 28px rgba(33,150,243,.4);
      }

      /* Center blurb */
      .center-blurb { position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%); z-index: 12;
        background: rgba(15,23,42,.7); border: 1px solid rgba(255,99,71,.5); border-radius: .85rem; padding: .85rem 1.1rem;
        font-weight: 600; letter-spacing: .015em; box-shadow: 0 14px 40px rgba(0,0,0,.35); text-align: center; }
      /* allow clicks to pass through the center blurb overlay */
      .center-blurb { pointer-events: none; }

      /* Red simulate button */
      .btn-red { background: linear-gradient(120deg,#ef4444,#dc2626) !important; border-color: rgba(255,99,71,.55) !important; color: #fff !important;
        box-shadow: 0 10px 24px rgba(239,68,68,.45) !important; }
      .btn-red:hover:enabled { box-shadow: 0 14px 28px rgba(239,68,68,.55) !important; }
      .btn-pulse { animation: pulseGlow 1.2s ease-in-out infinite; }
      @keyframes pulseGlow { 0%{ box-shadow: 0 0 0 0 rgba(239,68,68,.6);} 70%{ box-shadow: 0 0 0 12px rgba(239,68,68,0);} 100%{ box-shadow: 0 0 0 0 rgba(239,68,68,0);} }

      .credits { position: absolute; bottom: 1rem; right: 1rem; font-size: .8rem; color: rgba(220,230,244,.7); background: rgba(15,23,42,.65);
        padding: .4rem .75rem; border-radius: 999px; border: 1px solid rgba(100,116,139,.4); backdrop-filter: blur(4px); }
    </style>
  </head>
  <body>
    <div class="overlay">
      <h1>Impact Simulator!</h1>
      <p>Follow along as your asteroid strikes Earth. View mitigation strategies and impacts on human life.</p>
      <p> Click anywhere on the globe to view the impact at your chosen destination.</p>
      <div style="font-size:.85rem; color:#fcd34d; font-weight:500;">Asteroid: <span id="selectedAsteroidLabel">Default profile</span></div>
      <div id="selectedAsteroidStats" style="font-size:.78rem; color:#9ca3af;">Energy ~0.4 PJ · Diameter ~20 m</div>
      <div style="display:flex; gap:.5rem; flex-wrap:wrap; margin-top:.35rem">
        <button id="launchMeteor" type="button" class="btn-red" disabled>IMPACT!</button>
        <button id="returnToSelection" type="button" class="small">Choose a New Asteroid</button>
        <button id="pickImpact" type="button" title="Click on the globe to set the impact point">Pick Impact</button>
        <button id="timeline" type="button" class="btn-red" disabled>See Timeline</button>
        <button id="cityView" type="button" disabled>City view</button>
      </div>
      <div style="display:flex; align-items:center; gap:.5rem; font-size:.85rem; margin-top:.35rem">
        <strong style="font-weight:600">Impact:</strong>
        <span id="impactDisplay">--</span>
      </div>
      <div style="display:flex; align-items:center; gap:.6rem; margin-top:.35rem">
        <label for="impactAngle" style="font-size:.85rem; color:#c8d6e5">Impact angle:</label>
        <input id="impactAngle" type="range" min="0" max="85" step="1" value="30" style="flex:1" />
        <span id="impactAngleVal" style="min-width:2.5rem; text-align:right; font-variant-tabular-nums:tabular-nums">30°</span>
      </div>
      <div style="display:flex; align-items:center; gap:.6rem; margin-top:.35rem">
        <label for="speedMultiplier" style="font-size:.85rem; color:#c8d6e5">Speed:</label>
        <input id="speedMultiplier" type="range" min="0.2" max="5" step="0.1" value="1.0" style="flex:1" />
        <span id="speedMultiplierVal" style="min-width:2.5rem; text-align:right; font-variant-tabular-nums:tabular-nums">1.0×</span>
      </div>
      <div id="devPanel" style="display:none; margin-top:.75rem;">
        <div style="font-size:.8rem; opacity:.9; margin: .25rem 0 .4rem 0;">Captured camera code:</div>
        <pre id="devCameraCode" style="margin:0; padding:.75rem; background:rgba(2,8,23,.6); border:1px solid rgba(125,211,252,.25); border-radius:.5rem; overflow:auto; max-height:10rem;"></pre>
        <div style="display:flex; gap:.5rem; margin-top:.5rem;">
          <button id="copyCameraCode" type="button">Copy</button>
          <button id="useAsStart" type="button" title="Use this camera view as the initial camera on load">Use as Start</button>
          <button id="clearStart" type="button" title="Clear saved start camera">Clear Saved Start</button>
        </div>
      </div>
    </div>

    <!-- Center prompt shown on first load until an impact point is chosen -->
    <div id="centerBlurb" class="center-blurb">Choose your impact location...</div>

    <div id="cesiumContainer"></div>
    <div class="credits">Powered by CesiumJS + OpenStreetMap imagery</div>

    <script>
      window.CESIUM_BASE_URL = "./node_modules/cesium/Build/Cesium/";
      window.CESIUM_ION_TOKEN = "__CESIUM_ION_TOKEN__";
    </script>
    <script src="./node_modules/cesium/Build/Cesium/Cesium.js"></script>
    <!-- Turf & TopoJSON from CDNs (pinned versions) -->
    <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
    <script src="https://unpkg.com/topojson-client@3.1.0/dist/topojson-client.min.js"></script>

    <script>
      (function () {
        if (!window.Cesium) { console.error("Cesium failed to load. Check the script path."); return; }
        Cesium.buildModuleUrl.setBaseUrl(window.CESIUM_BASE_URL);

        const ionToken =
          typeof window.CESIUM_ION_TOKEN === "string" &&
          window.CESIUM_ION_TOKEN.trim() !== "" &&
          window.CESIUM_ION_TOKEN !== "__CESIUM_ION_TOKEN__"
            ? window.CESIUM_ION_TOKEN : null;
        if (ionToken) Cesium.Ion.defaultAccessToken = ionToken;

        const viewerOptions = {
          infoBox: false,
          animation: false,
          timeline: false,
          geocoder: false,
          homeButton: false,
          navigationHelpButton: false,
          fullscreenButton: false,
          selectionIndicator: false,
        };
        if (!ionToken) {
          viewerOptions.imageryProvider = new Cesium.OpenStreetMapImageryProvider({ url: "https://tile.openstreetmap.org/" });
          viewerOptions.terrainProvider = new Cesium.EllipsoidTerrainProvider();
        }

        Cesium.Math.setRandomNumberSeed(1234);
        const viewer = new Cesium.Viewer("cesiumContainer", viewerOptions);
        if (ionToken) {
          Cesium.CesiumTerrainProvider.fromIonAssetId(1).then((tp) => {
            viewer.terrainProvider = tp;                 // switch to real terrain
            console.log("Cesium World Terrain ready");   // optional debug
          });
        }
        viewer.clock.shouldAnimate = false;

        // === Dev camera loader: apply saved start camera if present ===
        try {
          const saved = localStorage.getItem("devCameraStart");
          if (saved) {
            const cfg = JSON.parse(saved);
            viewer.scene.camera.setView(cfg);
          }
        } catch (e) { /* ignore */ }

        // ==== Config ====
        const CITIES = {
          chicago: {
            lat: 41.8832,
            lon: -87.6324,
            cameraStart: {
              destination: { lon: -91.527187, lat: 5.866008, height: 14638136.82 },
              orientation: { heading: 6.283185, pitch: -1.570640, roll: 0.000000 }
            }
          }
        };
        const ASTEROIDS = {
          chelyabinskLike: { joules: 4.0e14, sizeMeters: 20 },
          a1: { joules: 1.2e15, sizeMeters: 45 },
          a2: { joules: 6.0e14, sizeMeters: 30 },
          a3: { joules: 2.5e15, sizeMeters: 80 },
          a4: { joules: 8.0e14, sizeMeters: 35 },
        };
        const MAJOR_CITIES = [
          { name: "New York City", lat: 40.7128, lon: -74.0060 },
          { name: "Los Angeles", lat: 34.0522, lon: -118.2437 },
          { name: "Chicago", lat: 41.8781, lon: -87.6298 },
          { name: "London", lat: 51.5074, lon: -0.1278 },
          { name: "Paris", lat: 48.8566, lon: 2.3522 },
          { name: "Madrid", lat: 40.4168, lon: -3.7038 },
          { name: "Tokyo", lat: 35.6762, lon: 139.6503 },
          { name: "Mexico City", lat: 19.4326, lon: -99.1332 },
          { name: "Sao Paulo", lat: -23.5505, lon: -46.6333 },
          { name: "Sydney", lat: -33.8688, lon: 151.2093 },
          { name: "Cairo", lat: 30.0444, lon: 31.2357 },
          { name: "Johannesburg", lat: -26.2041, lon: 28.0473 },
        ];
        const NEAREST_CITY_LABEL_THRESHOLD_KM = 250;
        const JOULE_RADIUS_SCALE = 1e-9;

        const CRATER_SCRAPER = (() => {
          const BASE_URL = 'https://impact.ese.ic.ac.uk/ImpactEarth/cgi-bin/crater.cgi';
          const BASE_SPEED_MPH = 32000;
          const MPH_TO_KM_PER_SEC = 0.00044704;
          const DEFAULT_PARAMS = {
            dist: '1',
            pdens: '3000',
            pdens_select: '0',
            tdens: '1000',
            tdens_select: '0',
          };
          const STORAGE_KEY = 'mpact:lastCraterReport';
          let cacheKey = null;
          let pending = null;
          let latestReport = null;

          function buildUrl(params) {
            return `${BASE_URL}?${new URLSearchParams(params).toString()}`;
          }

          function splitByBr(html) {
            if (!html) return [];
            return html
              .replace(/<br[^>]*>/gi, '|||BR|||')
              .split('|||BR|||')
              .map((s) => s.trim())
              .filter(Boolean);
          }

          function htmlToCleanText(fragment) {
            if (!fragment) return '';
            const normalized = fragment
              .replace(/<sup>(.*?)<\/sup>/gi, '^$1')
              .replace(/&nbsp;/gi, ' ');
            const template = document.createElement('template');
            template.innerHTML = normalized;
            const text = template.content.textContent || '';
            return text.replace(/\s+/g, ' ').trim();
          }

          function extractBullets(node) {
            const bullets = [];
            node.querySelectorAll('ul li').forEach((li) => {
              const t = htmlToCleanText(li.innerHTML || li.textContent);
              if (t) bullets.push(t);
            });
            return bullets;
          }

          function extractDdLines(dd) {
            const raw = dd.innerHTML || dd.textContent || '';
            const parts = splitByBr(raw);
            if (parts.length === 0) {
              const t = htmlToCleanText(raw);
              return t ? [t] : [];
            }
            return parts
              .map((p) => htmlToCleanText(p))
              .filter(Boolean);
          }

          function parseSections(html) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const data = {};
            const notice = doc.querySelector('body > p');
            if (notice) {
              const txt = notice.textContent?.replace(/\s+/g, ' ').trim();
              if (txt) data.notice = txt;
            }

            doc.querySelectorAll('dl').forEach((dl) => {
              const heading = dl.querySelector(':scope > dt > h2');
              if (!heading) return;
              const title = heading.textContent?.trim().replace(/:$/, '');
              if (!title) return;
              const section = [];
              dl.querySelectorAll(':scope > dd').forEach((dd) => {
                const bullets = extractBullets(dd);
                if (bullets.length) section.push({ bullets });
                const lines = extractDdLines(dd);
                lines.forEach((line) => section.push(line));
              });
              data[title] = section;
            });

            if (data['Your Inputs']) {
              const kv = {};
              for (const entry of data['Your Inputs']) {
                if (typeof entry !== 'string') continue;
                const idx = entry.indexOf(':');
                if (idx > -1) {
                  const key = entry.slice(0, idx).trim();
                  const val = entry.slice(idx + 1).trim();
                  if (key) kv[key] = val;
                }
              }
              data['Your Inputs'] = kv;
            }

            return data;
          }

          function sciToNumber(str) {
            if (!str) return NaN;
            const cleaned = str.replace(/,/g, '').trim();
            const sci = cleaned.match(/^([+-]?\d*\.?\d+)\s*(?:x|\*\s*10\^?)\s*10\^?(-?\d+)$/i);
            if (sci) return Number(sci[1]) * Math.pow(10, Number(sci[2]));
            const plain = cleaned.match(/^([+-]?\d*\.?\d+)(?:e([+-]?\d+))?$/i);
            if (plain) return Number(cleaned);
            return NaN;
          }

          function extractPairs(line) {
            const pairs = [];
            if (!line) return pairs;
            const chunks = line
              .split(/\s=\s|=| by /i)
              .map((s) => s.trim())
              .filter(Boolean);
            for (const chunk of chunks) {
              const match = chunk.match(/([+-]?\d*\.?\d+(?:\s*(?:x|\*\s*10\^?)\s*10\^?-?\d+)?)(.*)$/i);
              if (!match) continue;
              const numStr = match[1].trim();
              let unit = match[2].trim();
              unit = unit
                .replace(/\(.*?\)/g, '')
                .replace(/\s+per\s+/gi, '/')
                .replace(/\s+/g, ' ')
                .trim()
                .replace(/\bMegaTons(?: TNT)?\b/i, 'megatons')
                .replace(/\bJoules?\b/i, 'J')
                .replace(/\bmeters?\b/i, 'm')
                .replace(/\bkilometers?\b/i, 'km')
                .replace(/\bmiles?\b/i, 'miles')
                .replace(/\bfeet\b/i, 'ft')
                .replace(/\byears?\b/i, 'years')
                .replace(/\bkm\s*per\s*second\b/i, 'km/s')
                .replace(/\bmiles\s*per\s*second\b/i, 'miles/s')
                .replace(/\bkm\s*\/\s*second\b/i, 'km/s')
                .replace(/\bmiles\s*\/\s*second\b/i, 'miles/s')
                .replace(/\bkm3\b/i, 'km3')
                .replace(/\bmiles3\b/i, 'mi3')
                .replace(/\skg\/m\^?3/i, 'kg/m3');
              const value = sciToNumber(numStr);
              if (!Number.isNaN(value)) {
                pairs.push({ value, unit: unit || null });
              }
            }
            if (pairs.length === 0) {
              const fallback = line.match(/([+-]?\d*\.?\d+(?:\s*(?:x|\*\s*10\^?)\s*10\^?-?\d+)?)(?:\s*)years/i);
              if (fallback) {
                const value = sciToNumber(fallback[1]);
                if (!Number.isNaN(value)) pairs.push({ value, unit: 'years' });
              }
            }
            return pairs;
          }

          function putPair(obj, base, pair, idx = null) {
            let suffix = '';
            if (pair.unit) {
              suffix =
                '_' +
                pair.unit
                  .toLowerCase()
                  .replace(/\s+/g, '_')
                  .replace(/[^\w/]/g, '')
                  .replace(/\//g, '_per_');
            }
            const key = idx == null ? `${base}${suffix}` : `${base}_${idx}${suffix}`;
            obj[key] = pair.value;
          }

          function simplify(sections) {
            const out = {};
            if (sections['Your Inputs']) {
              for (const [k, v] of Object.entries(sections['Your Inputs'])) {
                const key = k.toLowerCase().replace(/[^\w]+/g, '_').replace(/^_+|_+$/g, '');
                out[`input_${key}`] = v;
              }
            }

            function scan(sectionName, matchers) {
              const lines = sections[sectionName] || [];
              for (const line of lines) {
                if (typeof line !== 'string') continue;
                for (const matcher of matchers) {
                  const hit = matcher.pattern.exec(line);
                  if (!hit) continue;
                  const pairs = extractPairs(line);
                  if (matcher.custom) {
                    matcher.custom(out, line, hit, pairs);
                  } else if (pairs.length) {
                    if (pairs.length === 1) putPair(out, matcher.base, pairs[0]);
                    else pairs.forEach((p, i) => putPair(out, matcher.base, p, i + 1));
                  }
                  break;
                }
              }
            }

            scan('Energy', [
              { pattern: /energy before atmospheric entry/i, base: 'energy_before_entry' },
              {
                pattern: /average interval between impacts/i,
                custom: (o, line) => {
                  const v = extractPairs(line).find((p) => (p.unit || '').includes('years'));
                  if (v) putPair(o, 'avg_interval', v);
                },
              },
            ]);

            scan('Atmospheric Entry', [
              { pattern: /begins to break.?up at an altitude/i, base: 'breakup_altitude' },
              { pattern: /mass of projectile strikes .* velocity/i, base: 'ground_velocity' },
              { pattern: /energy lost in the atmosphere/i, base: 'energy_lost_atmosphere' },
              { pattern: /impact energy/i, base: 'impact_energy' },
              {
                pattern: /ellipse of dimension/i,
                custom: (o, line) => {
                  const ps = extractPairs(line).filter((p) => (p.unit || '').toLowerCase() === 'km');
                  if (ps[0]) putPair(o, 'fragment_ellipse_km_a', ps[0]);
                  if (ps[1]) putPair(o, 'fragment_ellipse_km_b', ps[1]);
                },
              },
            ]);

            scan('Crater Dimensions', [
              { pattern: /transient crater.*diameter/i, base: 'transient_crater_diameter' },
              { pattern: /transient crater depth/i, base: 'transient_crater_depth' },
              { pattern: /final crater.*diameter/i, base: 'final_crater_diameter' },
              { pattern: /final crater depth/i, base: 'final_crater_depth' },
              { pattern: /volume of the target melted or vaporized/i, base: 'melt_volume' },
              { pattern: /average thickness/i, base: 'avg_melt_thickness' },
            ]);

            return out;
          }

          function estimateCraterRadius(report) {
            if (!report) return null;
            const flat = report.flat || report;
            if (!flat) return null;

            const unitSources = [
              ['final_crater_diameter_m', 1],
              ['final_crater_diameter_km', 1000],
              ['final_crater_diameter_miles', 1609.344],
              ['final_crater_diameter_ft', 0.3048],
              ['transient_crater_diameter_m', 1],
              ['transient_crater_diameter_km', 1000],
              ['transient_crater_diameter_miles', 1609.344],
              ['transient_crater_diameter_ft', 0.3048],
            ];

            for (const [key, factor] of unitSources) {
              const raw = flat[key];
              if (typeof raw !== 'number' || !Number.isFinite(raw) || raw <= 0) continue;
              return (raw * factor) / 2;
            }

            return null;
          }

          async function fetchReport(params) {
            const url = buildUrl(params);
            const response = await fetch(url, { mode: 'cors' });
            if (!response.ok) throw new Error(`Crater fetch failed: ${response.status}`);
            const html = await response.text();
            const sections = parseSections(html);
            const flat = simplify(sections);
            return { url, params, sections, flat, fetchedAt: Date.now() };
          }

          function persist(report) {
            try {
              sessionStorage.setItem(STORAGE_KEY, JSON.stringify(report));
            } catch (err) {
              console.warn('[crater] persist failed', err);
            }
          }

          function buildQueryParams(profile, angleDeg, speedMultiplier) {
            const diameter = Math.max(1, profile?.sizeMeters || 20);
            const kmPerSec = Math.max(0.1, BASE_SPEED_MPH * Math.max(speedMultiplier, 0.1) * MPH_TO_KM_PER_SEC);
            const angle = Math.max(1, Math.min(89, angleDeg || 30));
            return {
              ...DEFAULT_PARAMS,
              diam: diameter.toFixed(2),
              vel: kmPerSec.toFixed(2),
              theta: angle.toFixed(2),
            };
          }

          function ensureReport(params) {
            const key = JSON.stringify(params);
            if (cacheKey === key && pending) return pending;
            cacheKey = key;
            pending = fetchReport(params)
              .then((report) => {
                latestReport = report;
                persist(report);
                return report;
              })
              .catch((err) => {
                if (cacheKey === key) pending = null;
                throw err;
              });
            return pending;
          }

          return {
            buildQueryParams,
            ensureReport,
            estimateCraterRadius,
            getLatest: () => latestReport,
            persistLatest: () => { if (latestReport) persist(latestReport); },
            storageKey: STORAGE_KEY,
            baseSpeedMph: BASE_SPEED_MPH,
            mphToKmPerSec: MPH_TO_KM_PER_SEC,
          };
        })();

        const CITY_VIEW_CONTEXT_KEY = 'mpact:cityViewContext';

        const METEOR = {
          startLon: -120.0, startLat: 80.0, startAlt: 900000.0,
          targetCity: "chicago",
          asteroidId: "chelyabinskLike",
          endLon: null, endLat: null, endAlt: 1000.0,
          flightSeconds: 20, trailSeconds: 20,
          useModel: false, modelUri: "/models/asteroid.glb",
          tailExtensionFactor: 3.0,              // how many path-lengths to extend backward before the animation
          tailMaxPoints: 600,                    // cap the stored tail to limit memory
          tailAddMinDistance: 5000,              // meters between recorded samples along the tail
          craterReport: null,
          craterParams: null,
          craterParamsKey: null,
          cityViewContext: null,
          craterRadiusEstimate: null,
        };

        const STORAGE_KEY = 'mpact:selectedAsteroid';
        let storedSelection = null;
        try {
          const raw = sessionStorage.getItem(STORAGE_KEY);
          if (raw) storedSelection = JSON.parse(raw);
        } catch (err) {
          console.warn('Unable to parse stored asteroid selection:', err);
        }
        if (storedSelection) {
          sessionStorage.removeItem(STORAGE_KEY);
          if (storedSelection.meteorProfileId) {
            METEOR.asteroidId = storedSelection.meteorProfileId;
            ASTEROIDS[storedSelection.meteorProfileId] = {
              joules: storedSelection.energyJoules || ASTEROIDS.chelyabinskLike.joules,
              sizeMeters: storedSelection.sizeMeters || ASTEROIDS.chelyabinskLike.sizeMeters,
            };
          }
          if (storedSelection.targetCity && CITIES[storedSelection.targetCity]) {
            METEOR.targetCity = storedSelection.targetCity;
          }
          const labelEl = document.getElementById('selectedAsteroidLabel');
          if (labelEl) {
            labelEl.textContent = storedSelection.name || storedSelection.meteorProfileId || 'Custom';
          }
          const statsEl = document.getElementById('selectedAsteroidStats');
          if (statsEl) {
            const energyPJ = storedSelection.energyJoules ? (storedSelection.energyJoules).toFixed(2) : '0.40';
            const size = storedSelection.sizeMeters ? storedSelection.sizeMeters.toFixed(0) : '20';
            statsEl.textContent = `Energy ~${energyPJ} Megatons of TNT · Diameter ~${size} m`;
          }
        } else {
          const labelEl = document.getElementById('selectedAsteroidLabel');
          if (labelEl) labelEl.textContent = 'Default profile';
          const statsEl = document.getElementById('selectedAsteroidStats');
          if (statsEl) statsEl.textContent = 'Energy ~0.4 Megatons · Diameter ~20 m';
        }
        const targetCity = CITIES[METEOR.targetCity];
        METEOR.endLon = targetCity ? targetCity.lon : -90.0;
        METEOR.endLat = targetCity ? targetCity.lat : 33.0;
        // reflect defaults in UI
        setTimeout(() => {
          const el = document.getElementById('impactDisplay');
          if (el) el.textContent = `${METEOR.endLat.toFixed(4)}°, ${METEOR.endLon.toFixed(4)}°`;
        }, 0);

        // === Curved path helper (great-circle + altitude profile) ==========
        function buildGeodesicPathSamples(opts) {
          const {
            startLon, startLat, startAlt,
            endLon, endLat, endAlt,
            flightSeconds, numPoints = 96,
            startTime = Cesium.JulianDate.now(),
            altExponent = 1.15,
          } = opts;

          const startCarto = Cesium.Cartographic.fromDegrees(startLon, startLat);
          const endCarto   = Cesium.Cartographic.fromDegrees(endLon, endLat);
          const geodesic   = new Cesium.EllipsoidGeodesic(startCarto, endCarto);

          const samples = new Cesium.SampledPositionProperty();
          for (let i = 0; i < numPoints; i++) {
            const t = i / (numPoints - 1);
            const when = Cesium.JulianDate.addSeconds(startTime, t * flightSeconds, new Cesium.JulianDate());
            const p = geodesic.interpolateUsingFraction(t);

            // Altitude profile
            const h = startAlt * Math.pow(1 - t, altExponent) + endAlt * (1 - Math.pow(1 - t, altExponent));

            const pos = Cesium.Cartesian3.fromRadians(p.longitude, p.latitude, h);
            samples.addSample(when, pos);
          }

          samples.setInterpolationOptions({
            interpolationDegree: 2,
            interpolationAlgorithm: Cesium.LagrangePolynomialApproximation,
          });

          return { samples, geodesic, startCarto, endCarto };
        }
        // ===================================================================

        function makeParticleImage(size = 32) {
          const canvas = document.createElement("canvas");
          canvas.width = size; canvas.height = size;
          const ctx = canvas.getContext("2d");
          const g = ctx.createRadialGradient(size/2, size/2, 1, size/2, size/2, size/2);
          g.addColorStop(0.0,"rgba(255,255,255,1)");
          g.addColorStop(0.25,"rgba(255,210,0,0.95)");
          g.addColorStop(1.0,"rgba(255,120,0,0)");
          ctx.fillStyle = g;
          ctx.beginPath(); ctx.arc(size/2, size/2, size/2, 0, Math.PI*2); ctx.fill();
          return canvas;
        }

        // NEW: simple crosshair image for the chosen impact point
        function makeCrossImage(size = 40, color = 'rgba(255,80,80,1)') {
          const c = document.createElement('canvas');
          c.width = size; c.height = size;
          const x = c.getContext('2d');
          x.strokeStyle = color;
          x.lineWidth = Math.max(2, size * 0.08);
          x.lineCap = 'round';
          const m = size * 0.2;
          x.beginPath();
          x.moveTo(m, size/2); x.lineTo(size-m, size/2);
          x.moveTo(size/2, m); x.lineTo(size/2, size-m);
          x.stroke();
          return c;
        }

        // === water/land helper =====================================
        // remember the last pick's classification so we can color rings later
        let lastImpactIsWater = false;
        
        const WATER_CUTOFF_M = 1.0;

        // === Water/land via CDN masks (robust) ====================================
        const RES = "110m";        // "110m" fast; switch to "50m" for finer coasts later
        const OCEAN_ONLY = false;  // true => oceans only (lakes count as land)

        let landMask = null;       // FeatureCollection of Polygon/MultiPolygon
        let lakesMask = null;      // FeatureCollection (optional)
        let masksReady = null;

        // Always return a FeatureCollection (wrap single Feature if needed)
        function asFeatureCollection(geo) {
          if (!geo) return null;
          if (geo.type === "FeatureCollection") return geo;
          if (geo.type === "Feature") {
            return { type: "FeatureCollection", features: [geo] };
          }
          // bare geometry -> wrap in a Feature, then FC
          return { type: "FeatureCollection", features: [{ type: "Feature", properties: {}, geometry: geo }] };
        }

        function pointInAny(pt, featureCollection) {
          return Boolean(
            featureCollection &&
            Array.isArray(featureCollection.features) &&
            featureCollection.features.some(f => turf.booleanPointInPolygon(pt, f))
          );
        }

        function loadMasksFromCDN() {
          const landURL  = `https://unpkg.com/world-atlas@2.0.2/land-${RES}.json`;
          const lakesURL = `https://unpkg.com/world-atlas@2.0.2/lakes-${RES}.json`;

          return Promise.allSettled([
            fetch(landURL).then(r => r.json()),
            fetch(lakesURL).then(r => r.ok ? r.json() : null)
          ]).then(([landRes, lakesRes]) => {
            if (landRes.status === "fulfilled") {
              const topo = landRes.value;
              const landGeo = topojson.feature(topo, topo.objects.land);
              landMask = asFeatureCollection(landGeo);
            }
            if (lakesRes.status === "fulfilled" && lakesRes.value) {
              const topo = lakesRes.value;
              const lakesGeo = topojson.feature(topo, topo.objects.lakes);
              lakesMask = asFeatureCollection(lakesGeo);
            }
            console.log("[masks] land FC?", !!landMask, "lakes FC?", !!lakesMask, "res:", RES);
            if (!landMask || !landMask.features?.length) {
              throw new Error("Failed to load/normalize land mask");
            }
          });
        }
        masksReady = loadMasksFromCDN();

        // Return true if point is WATER at (lon, lat)
        function isWaterByMask(lon, lat) {
          const pt = turf.point([lon, lat]); // [lon, lat]
          const onLand = pointInAny(pt, landMask);
          if (!OCEAN_ONLY) return !onLand;   // oceans + lakes = water
          const inLake = pointInAny(pt, lakesMask); // false if lakesMask is null
          return !onLand && !inLake;         // oceans-only
        }
        // ==========================================================================


        // Helper to apply a camera setView using degrees-based config
        function applyCameraFromConfig(cfg) {
          if (!cfg) return;
          viewer.scene.camera.setView({
            destination: Cesium.Cartesian3.fromDegrees(
              cfg.destination.lon,
              cfg.destination.lat,
              cfg.destination.height
            ),
            orientation: cfg.orientation
          });
        }

        const launchButton = document.getElementById("launchMeteor");
        const returnButton = document.getElementById("returnToSelection");
        returnButton?.addEventListener('click', () => { window.location.href = '/'; });
        const angleSlider = document.getElementById("impactAngle");
        const angleVal    = document.getElementById("impactAngleVal");
        let impactAngleDeg = Number(angleSlider?.value || 30);
        angleSlider?.addEventListener("input", () => {
          impactAngleDeg = Number(angleSlider.value);
          angleVal.textContent = `${impactAngleDeg}°`;
          if (METEOR.cityViewContext && !lastImpactIsWater) refreshCraterReport();
        });
        const speedSlider = document.getElementById("speedMultiplier");
        const speedVal    = document.getElementById("speedMultiplierVal");
        let speedMult = Number(speedSlider?.value || 1.0);
        speedSlider?.addEventListener("input", () => {
          speedMult = Number(speedSlider.value);
          speedVal.textContent = `${(speedMult * 32000).toFixed(0)} mph`;
          viewer.clock.multiplier = speedMult;
          if (METEOR.cityViewContext && !lastImpactIsWater) refreshCraterReport();
        });

        let meteorActive = false;
        let impactCircleEntities = [];
        let impactCircleTimers = [];
        let epicenterSpheres = [];
        let activeTrail = null;
        let trajectoryEntity = null; // persistent path shown until next run
        let trajectoryPositions = []; // updated in real time to extend the trail
        let impactCrossEntity = null; // NEW crosshair marker
        let cityLabelEntity = null;
        let cityViewPayload = null;

        function clearEpicenterSpheres() {
          epicenterSpheres.forEach((e) => viewer.entities.remove(e));
          epicenterSpheres = [];
        }
        function createEpicenterSpheres() {
          clearEpicenterSpheres();
          const radii = [60, 120, 200, 300]; // very small concentric spheres (meters)
          const pos = Cesium.Cartesian3.fromDegrees(METEOR.endLon, METEOR.endLat, METEOR.endAlt);
          radii.forEach((r, i) => {
            const ent = viewer.entities.add({
              position: pos,
              ellipsoid: {
                radii: new Cesium.Cartesian3(r, r, r),
                material: Cesium.Color.ORANGE.withAlpha(0.22 + i * 0.12),
                outline: true,
                outlineColor: Cesium.Color.ORANGE.withAlpha(0.65 + i * 0.06),
                stackPartitions: 16,
                slicePartitions: 16,
              },
            });
            epicenterSpheres.push(ent);
          });
        }

        // NEW: create/update a crosshair billboard at the chosen point
        function updateImpactCross(color = 'rgba(255,80,80,1)') {
          if (impactCrossEntity) {
            viewer.entities.remove(impactCrossEntity);
            impactCrossEntity = null;
          }
          impactCrossEntity = viewer.entities.add({
            position: Cesium.Cartesian3.fromDegrees(METEOR.endLon, METEOR.endLat, 0.0),
            billboard: {
              image: makeCrossImage(44, color),
              verticalOrigin: Cesium.VerticalOrigin.CENTER,
              horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
              disableDepthTestDistance: Number.POSITIVE_INFINITY,
              scaleByDistance: new Cesium.NearFarScalar(500.0, 1.2, 5000000.0, 0.6)
            }
          });
        }

        // NEW: bake the flown trajectory into a static polyline that persists
        function bakeFinalTrajectory() {
          if (trajectoryEntity) {
            viewer.entities.remove(trajectoryEntity);
            trajectoryEntity = null;
          }
          if (trajectoryPositions.length >= 2) {
            trajectoryEntity = viewer.entities.add({
              polyline: {
                positions: trajectoryPositions.slice(),
                width: 6,
                material: new Cesium.PolylineGlowMaterialProperty({
                  color: Cesium.Color.ORANGE.withAlpha(0.9),
                  glowPower: 0.15
                })
              }
            });
          }
        }

        function clearCityLabel() {
          if (!cityLabelEntity) return;
          viewer.entities.remove(cityLabelEntity);
          cityLabelEntity = null;
        }

        function refreshCraterReport() {
          const asteroidProfile = ASTEROIDS[METEOR.asteroidId];
          if (!asteroidProfile) return null;
          const craterParams = CRATER_SCRAPER.buildQueryParams(asteroidProfile, impactAngleDeg, speedMult);
          const paramsKey = JSON.stringify(craterParams);
          const paramsChanged = METEOR.craterParamsKey !== paramsKey;
          METEOR.craterParams = craterParams;
          METEOR.craterParamsKey = paramsKey;
          if (paramsChanged) METEOR.craterReport = null;
          return CRATER_SCRAPER.ensureReport(craterParams)
            .then((report) => {
              METEOR.craterReport = report;
              window.latestCraterReport = report;
              return report;
            })
            .catch((err) => {
              console.warn('[crater] unable to fetch crater report', err);
              throw err;
            });
        }

        function markCityViewPending(message = 'City view unlocks after impact completes.') {
          if (!cityViewBtn) return;
          cityViewBtn.disabled = true;
          cityViewBtn.classList.remove('btn-ready');
          cityViewBtn.title = message;
        }

        function resetCityViewButton(reason = 'City view available after selecting a land impact.') {
          if (!cityViewBtn) return;
          cityViewPayload = null;
          METEOR.cityViewContext = null;
          markCityViewPending(reason);
        }

        function setCityViewContext({ impactLat, impactLon } = {}) {
          const lat = Number(impactLat);
          const lon = Number(impactLon);
          if (!Number.isFinite(lat) || !Number.isFinite(lon)) return;
          METEOR.cityViewContext = { impactLat: lat, impactLon: lon };
          cityViewPayload = { impactLat: lat.toFixed(4), impactLon: lon.toFixed(4) };
          refreshCraterReport();
        }

        function activateCityViewButton(message = '') {
          if (!cityViewBtn) return;
          if (!METEOR.cityViewContext) return;
          cityViewBtn.disabled = false;
          cityViewBtn.classList.add('btn-ready');
          cityViewBtn.title = message || `Inspect impact site (${METEOR.cityViewContext.impactLat.toFixed(2)}°, ${METEOR.cityViewContext.impactLon.toFixed(2)}°)`;
        }

        function highlightNearbyCity(city, distanceKm) {
          clearCityLabel();
          const labelHeight = Math.max(METEOR.endAlt + 5000, 4000);
          cityLabelEntity = viewer.entities.add({
            position: Cesium.Cartesian3.fromDegrees(city.lon, city.lat, labelHeight),
            label: {
              text: `${city.name} (${distanceKm.toFixed(1)} km)`,
              font: '16px "Segoe UI", sans-serif',
              fillColor: Cesium.Color.fromCssColorString('#d1d5db'),
              outlineColor: Cesium.Color.BLACK,
              outlineWidth: 2,
              style: Cesium.LabelStyle.FILL_AND_OUTLINE,
              verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
              pixelOffset: new Cesium.Cartesian2(0, -12),
              translucencyByDistance: new Cesium.NearFarScalar(500.0, 1.0, 2500000.0, 0.2),
              disableDepthTestDistance: Number.POSITIVE_INFINITY,
            },
          });
        }

        function findNearestMajorCity(lat, lon) {
          const impactCarto = Cesium.Cartographic.fromDegrees(lon, lat);
          let nearest = null;
          for (const city of MAJOR_CITIES) {
            const cityCarto = Cesium.Cartographic.fromDegrees(city.lon, city.lat);
            const geodesic = new Cesium.EllipsoidGeodesic(impactCarto, cityCarto);
            const distanceKm = (geodesic.surfaceDistance || 0) / 1000;
            if (!Number.isFinite(distanceKm)) continue;
            if (!nearest || distanceKm < nearest.distanceKm) {
              nearest = { city, distanceKm };
            }
          }
          return nearest;
        }

        async function startMeteorRun() {
          if (!launchButton) { console.error("Simulate button is missing."); return; }
          if (meteorActive) return;

          resetCityViewButton('City view unlocks after impact completes.');
          clearCityLabel();

          // Cleanup from prior runs (keep epicenter spheres & crosshair until new pick)
          impactCircleTimers.forEach((id) => window.clearTimeout(id));
          impactCircleTimers = [];
          impactCircleEntities.forEach((e) => viewer.entities.remove(e));
          impactCircleEntities = [];
          if (activeTrail) { viewer.scene.primitives.remove(activeTrail); activeTrail = null; }
          if (trajectoryEntity) { viewer.entities.remove(trajectoryEntity); trajectoryEntity = null; } // clear previous baked path ONLY when a new sim starts
          trajectoryPositions = [];

          launchButton.disabled = true;
          launchButton.classList.remove('btn-pulse');

          const asteroidProfile = ASTEROIDS[METEOR.asteroidId];

          let craterReport = METEOR.craterReport;
          try {
            const maybePromise = refreshCraterReport();
            if (maybePromise && typeof maybePromise.then === 'function') {
              craterReport = await maybePromise;
            }
          } catch (err) {
            console.warn('[crater] using fallback impact radius after fetch error', err);
          }
          if (!craterReport) craterReport = METEOR.craterReport;

          const craterRadiusEstimate = CRATER_SCRAPER.estimateCraterRadius(craterReport);
          const fallbackRadius = asteroidProfile
            ? Math.max(asteroidProfile.sizeMeters * 500.0, asteroidProfile.joules * JOULE_RADIUS_SCALE)
            : 50000.0;
          const impactRadius = Number.isFinite(craterRadiusEstimate) && craterRadiusEstimate > 0
            ? craterRadiusEstimate
            : fallbackRadius;
          METEOR.craterRadiusEstimate = impactRadius;

          meteorActive = true;
          if (pickBtn) pickBtn.disabled = true;

          const startTime = Cesium.JulianDate.now();
          const stopTime = Cesium.JulianDate.addSeconds(startTime, METEOR.flightSeconds, new Cesium.JulianDate());

          viewer.clock.startTime = startTime.clone();
          viewer.clock.stopTime = stopTime.clone();
          viewer.clock.currentTime = startTime.clone();
          viewer.clock.clockRange = Cesium.ClockRange.CLAMPED;
          viewer.clock.multiplier = speedMult;
          viewer.clock.shouldAnimate = false;

          // === Build the curved path (trajectory) ==========================
          const tmpGeodesic = new Cesium.EllipsoidGeodesic(
            Cesium.Cartographic.fromDegrees(METEOR.startLon, METEOR.startLat),
            Cesium.Cartographic.fromDegrees(METEOR.endLon, METEOR.endLat)
          );
          const L = tmpGeodesic.surfaceDistance; // meters
          const angleRad = Cesium.Math.toRadians(Math.min(85, Math.max(0, impactAngleDeg)));

          // Choose start altitude so that dh/ds at end matches -tan(angle)
          const startAltForAngle = METEOR.endAlt + L * Math.tan(angleRad);

          const {
            samples: positionProperty,
            startCarto,
            endCarto,
          } = buildGeodesicPathSamples({
            startLon: METEOR.startLon, startLat: METEOR.startLat, startAlt: startAltForAngle,
            endLon: METEOR.endLon,     endLat: METEOR.endLat,     endAlt: METEOR.endAlt,
            flightSeconds: METEOR.flightSeconds,
            numPoints: 128,
            startTime,
            altExponent: 1 // linear to satisfy slope requirement at impact
          });

          const startCartesian = Cesium.Cartesian3.fromRadians(
            startCarto.longitude,
            startCarto.latitude,
            startAltForAngle
          );
          const endCartesian = Cesium.Cartesian3.fromRadians(
            endCarto.longitude,
            endCarto.latitude,
            METEOR.endAlt
          );

          const tailExtensionFactor = METEOR.tailExtensionFactor || 3.0;
          const tailVector = Cesium.Cartesian3.subtract(
            startCartesian,
            endCartesian,
            new Cesium.Cartesian3()
          );
          Cesium.Cartesian3.multiplyByScalar(tailVector, tailExtensionFactor, tailVector);
          const tailCartesian = Cesium.Cartesian3.add(
            startCartesian,
            tailVector,
            new Cesium.Cartesian3()
          );

          trajectoryPositions = [
            Cesium.Cartesian3.clone(startCartesian),
          ];

          const baseEntity = {
            position: positionProperty,
            orientation: new Cesium.VelocityOrientationProperty(positionProperty),
            path: {
              resolution: 1,
              leadTime: 0,
              trailTime: METEOR.trailSeconds,
              material: new Cesium.PolylineGlowMaterialProperty({ color: Cesium.Color.ORANGE, glowPower: 0.25 }),
              width: 8,
            },
          };

          const meteorEntity = viewer.entities.add(
            METEOR.useModel
              ? { ...baseEntity, model: { uri: METEOR.modelUri, minimumPixelSize: 32, scale: 1.0 } }
              : { ...baseEntity, point: { pixelSize: 12, color: Cesium.Color.YELLOW.withAlpha(0.95), outlineColor: Cesium.Color.ORANGE, outlineWidth: 2 } }
          );

          // Particle plume attached to meteor orientation
          const trailDuration = METEOR.flightSeconds + 20;
          const plume = new Cesium.ParticleSystem({
            image: makeParticleImage(32),
            startScale: 1.0, endScale: 0.5, emissionRate: 140,
            particleLife: trailDuration, lifetime: trailDuration, speed: 800.0,
            emitter: new Cesium.ConeEmitter(Cesium.Math.toRadians(10)), sizeInMeters: true,
          });
          viewer.scene.primitives.add(plume);
          activeTrail = plume;

          let burstTimeoutId = null;
          let burstPrimitive = null;
          let preRenderCallback;

          const finalize = () => {
            if (burstTimeoutId !== null) { window.clearTimeout(burstTimeoutId); burstTimeoutId = null; }
            viewer.scene.preRender.removeEventListener(preRenderCallback);
            if (burstPrimitive) { viewer.scene.primitives.remove(burstPrimitive); burstPrimitive = null; }
            viewer.entities.remove(meteorEntity);
            viewer.clock.shouldAnimate = false;
            meteorActive = false;
            if (pickBtn) pickBtn.disabled = false;
            launchButton.disabled = false;
            launchButton.classList.add('btn-pulse');
            // Ensure spheres are present at the epicenter
            createEpicenterSpheres();
            const nearestCity = findNearestMajorCity(METEOR.endLat, METEOR.endLon);
            let labelMessage = 'Inspect impact site';
            if (nearestCity && nearestCity.distanceKm <= NEAREST_CITY_LABEL_THRESHOLD_KM) {
              highlightNearbyCity(nearestCity.city, nearestCity.distanceKm);
              labelMessage = `Inspect impact site near ${nearestCity.city.name} (${nearestCity.distanceKm.toFixed(1)} km)`;
            } else {
              clearCityLabel();
            }

            if (!lastImpactIsWater) {
              setCityViewContext({ impactLat: METEOR.endLat, impactLon: METEOR.endLon });
              activateCityViewButton(labelMessage);
            } else {
              clearCityLabel();
              resetCityViewButton('Impact is over water; city view unavailable.');
            }
          };

          const rotationScratch = new Cesium.Matrix3();
          const flipMatrix = Cesium.Matrix3.fromRotationY(Math.PI, new Cesium.Matrix3());
          const plumeMatrix = new Cesium.Matrix4();

          preRenderCallback = function (_scene, time) {
            const now = time || viewer.clock.currentTime;
            const position = baseEntity.position.getValue(now);
            if (!position) return;

            const orientation = meteorEntity.orientation.getValue(now);
            if (orientation) {
              Cesium.Matrix3.fromQuaternion(orientation, rotationScratch);
              Cesium.Matrix3.multiply(rotationScratch, flipMatrix, rotationScratch);
              Cesium.Matrix4.fromRotationTranslation(rotationScratch, position, plumeMatrix);
              plume.modelMatrix = plumeMatrix;
            } else {
              Cesium.Transforms.eastNorthUpToFixedFrame(position, undefined, plumeMatrix);
              plume.modelMatrix = plumeMatrix;
            }

            const lastRecorded = trajectoryPositions[trajectoryPositions.length - 1];
            const minDistance = METEOR.tailAddMinDistance || 5000;
            const shouldAdd = !lastRecorded || Cesium.Cartesian3.distance(position, lastRecorded) > minDistance;
            if (shouldAdd) {
              trajectoryPositions.push(Cesium.Cartesian3.clone(position));
              const maxPoints = METEOR.tailMaxPoints || 600;
              if (trajectoryPositions.length > maxPoints) {
                const excess = trajectoryPositions.length - maxPoints;
                trajectoryPositions.splice(1, excess); // preserve tail anchor at index 0
              }
            }

            const cartographic = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);
            const lowAltitude = cartographic ? cartographic.height < 1500.0 : false;
            const reachedEnd = Cesium.JulianDate.greaterThanOrEquals(now, stopTime);

            if (reachedEnd || lowAltitude) {
              viewer.scene.preRender.removeEventListener(preRenderCallback);

              meteorEntity.show = false;
              viewer.clock.currentTime = stopTime.clone();

              const finalRecorded = trajectoryPositions[trajectoryPositions.length - 1];
              if (!finalRecorded || !Cesium.Cartesian3.equalsEpsilon(endCartesian, finalRecorded, Cesium.Math.EPSILON3)) {
                trajectoryPositions.push(Cesium.Cartesian3.clone(endCartesian));
              }

              // NEW: bake the full flown path into a persistent polyline
              bakeFinalTrajectory();

              const impactCartesian = Cesium.Cartesian3.fromDegrees(METEOR.endLon, METEOR.endLat, 10.0);
              burstPrimitive = new Cesium.ParticleSystem({
                image: makeParticleImage(48), startScale: 2.0, endScale: 6.0,
                emissionRate: 0, lifetime: 1.6, particleLife: 0.8, speed: 120.0, sizeInMeters: true,
                emitter: new Cesium.SphereEmitter(80.0),
                modelMatrix: Cesium.Transforms.eastNorthUpToFixedFrame(impactCartesian),
                bursts: [ new Cesium.ParticleBurst({ time: 0.0, minimum: 300, maximum: 300 }) ],
              });
              viewer.scene.primitives.add(burstPrimitive);

              // Expanding 2D shock rings (keep existing visual)
              if (impactCircleEntities.length === 0) {
                const circleCount = 5, delayMs = 1000;
                const radiusStep = impactRadius / circleCount;
                const baseColor = lastImpactIsWater ? Cesium.Color.BLUE : Cesium.Color.RED;
                for (let i = 0; i < circleCount; i++) {
                  const timerId = window.setTimeout(() => {
                    const radius = radiusStep * (i + 1);
                    const circle = viewer.entities.add({
                      position: Cesium.Cartesian3.fromDegrees(METEOR.endLon, METEOR.endLat, METEOR.endAlt),
                      ellipse: {
                        semiMajorAxis: radius, semiMinorAxis: radius, height: METEOR.endAlt,
                        material: baseColor.withAlpha(0.25 + i * 0.12),
                        outline: true, outlineColor: baseColor.withAlpha(0.6 + i * 0.08), outlineWidth: 3,
                      },
                    });
                    impactCircleEntities.push(circle);
                  }, i * delayMs);
                  impactCircleTimers.push(timerId);
                }
              }

              burstTimeoutId = window.setTimeout(finalize, 2000);
            }
          };

          viewer.scene.preRender.addEventListener(preRenderCallback);
          viewer.clock.shouldAnimate = true; // Go!
        }

        // === Impact picking (click anywhere to set endLon/Lat) ===
        const pickBtn = document.getElementById("pickImpact");
        const cityViewBtn = document.getElementById("cityView");
        const impactDisp = document.getElementById("impactDisplay");
        const centerBlurb = document.getElementById("centerBlurb");

        function updateImpactDisplay() {
          if (impactDisp) impactDisp.textContent = `${METEOR.endLat.toFixed(4)}°, ${METEOR.endLon.toFixed(4)}°`;
        }
        updateImpactDisplay();
        resetCityViewButton();

        // Start in picking mode immediately
        let pickingImpact = true;
        pickBtn && (pickBtn.textContent = "Clear selection");
        viewer.canvas.style.cursor = "crosshair";

        const clickHandler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
        pickBtn?.addEventListener("click", () => {
          pickingImpact = !pickingImpact;
          pickBtn.textContent = pickingImpact ? "Click on globe…" : "Pick Impact";
          viewer.canvas.style.cursor = pickingImpact ? "crosshair" : "";
          if (pickingImpact) {
            if (centerBlurb) centerBlurb.style.display = 'block';
            resetCityViewButton();
            clearCityLabel();
          }
        });

        // === Impact picking (click anywhere to set endLon/Lat) ===
        clickHandler.setInputAction(async (evt) => {
          if (!pickingImpact) return;

          console.log("[pick] clicked", evt.position); // debug

          const scene = viewer.scene;

          // Try 1: 3D scene depth-based pick (when available)
          let cartesian = scene.pickPosition?.(evt.position);

          // Try 2: Ray/globe intersection
          if (!cartesian) {
            const ray = scene.camera.getPickRay(evt.position);
            cartesian = scene.globe.pick(ray, scene);
          }

          // Try 3: Ellipsoid fallback (agit ways works if you click on the globe)
          if (!cartesian) {
            cartesian = scene.camera.pickEllipsoid(evt.position, Cesium.Ellipsoid.WGS84);
          }

          if (!cartesian) {
            console.warn("[pick] no cartesian found (clicked UI or outside globe?)");
            return;
          }

          const carto = Cesium.Cartographic.fromCartesian(cartesian);
          const lon = Cesium.Math.toDegrees(carto.longitude);
          const lat = Cesium.Math.toDegrees(carto.latitude);
          METEOR.endLon = lon;
          METEOR.endLat = lat;
          updateImpactDisplay();
          resetCityViewButton('Evaluating impact location...');

          // Water/land classification
          await masksReady;
          lastImpactIsWater = isWaterByMask(lon, lat);
          const crossColor = lastImpactIsWater ? 'rgba(64,160,255,1)' : 'rgba(255,80,80,1)';

          createEpicenterSpheres();
          updateImpactCross(crossColor);
          clearCityLabel();

          if (lastImpactIsWater) {
            resetCityViewButton('Impact is over water; city view unavailable.');
          } else {
            setCityViewContext({ impactLat: METEOR.endLat, impactLon: METEOR.endLon });
            markCityViewPending();
          }

          if (centerBlurb) setTimeout(() => (centerBlurb.style.display = 'none'), 600);
          if (launchButton) { launchButton.disabled = false; launchButton.classList.add('btn-pulse'); }

          pickingImpact = false;
          pickBtn && (pickBtn.textContent = "Pick Impact");
          viewer.canvas.style.cursor = "";
        }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

        // === End impact picking ===

        if (launchButton) launchButton.addEventListener("click", () => {
          startMeteorRun().catch((err) => console.error('[meteor] run failed', err));
        });
        cityViewBtn?.addEventListener("click", async () => {
          if (!cityViewPayload) return;

          const impactLat = Number(METEOR.cityViewContext?.impactLat ?? METEOR.endLat);
          const impactLon = Number(METEOR.cityViewContext?.impactLon ?? METEOR.endLon);
          if (!Number.isFinite(impactLat) || !Number.isFinite(impactLon)) {
            console.warn('[city-view] missing impact coordinates');
            return;
          }

          const context = {
            impactLat,
            impactLon,
            craterRadiusMeters: null,
          };

          let report = METEOR.craterReport;
          if (!report) {
            try {
              const promise = refreshCraterReport();
              if (promise && typeof promise.then === 'function') {
                report = await promise;
              } else if (METEOR.craterParams) {
                report = await CRATER_SCRAPER.ensureReport(METEOR.craterParams);
              }
            } catch (err) {
              console.warn('[crater] fetch before city view failed', err);
            }
          }

          if (report) {
            const radius = CRATER_SCRAPER.estimateCraterRadius(report);
            if (Number.isFinite(radius) && radius > 0) {
              context.craterRadiusMeters = radius;
            }
            try {
              sessionStorage.setItem(CRATER_SCRAPER.storageKey, JSON.stringify(report));
            } catch (err) {
              console.warn('[crater] unable to persist report for city view', err);
            }
          }

          try {
            sessionStorage.setItem(CITY_VIEW_CONTEXT_KEY, JSON.stringify(context));
          } catch (err) {
            console.warn('[city-view] unable to persist context', err);
          }

          const destination = new URL('./city-view-placeholder.html', window.location.href);
          for (const [key, value] of Object.entries(cityViewPayload)) {
            destination.searchParams.set(key, value);
          }
          window.location.href = destination.toString();
        });
      })();

    </script>
  </body>
</html>
