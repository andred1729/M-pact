<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Globe Simulator</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="./node_modules/cesium/Build/Cesium/Widgets/widgets.css" />

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bitcount+Single+Ink:wght@100..900&display=swap" rel="stylesheet">

    <style>

      
      :root { color-scheme: dark; font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; }
      body { margin: 0; background: #0b1a2a; color: #f1f3f5; overflow: hidden; }
      #cesiumContainer { position: absolute; inset: 0; }
      .overlay {
        position: absolute; top: 1.5rem; left: 1.5rem; display: flex; flex-direction: column; gap: 0.5rem; z-index: 10;
        background: rgba(6,17,32,.8); border: 1px solid rgba(110,191,244,.35); border-radius: .75rem; padding: 1rem 1.25rem;
        max-width: 20rem; backdrop-filter: blur(6px); box-shadow: 0 12px 35px rgba(0,0,0,.35);
      }
      .overlay h1 { margin: 0; font-size: 1.5rem; color: #cf6de2; font-family: 'Bitcount Single Ink', sans-serif;}
      .overlay p { margin: 0; font-size: .95rem; line-height: 1.45; color: #c8d6e5; }
      .overlay button {
        margin-top: .75rem; padding: .5rem 1.1rem; font-size: .85rem; border: 1px solid rgba(125,211,252,.45); border-radius: 999px;
        background: linear-gradient(120deg,#1d8cf8,#935ade); color: #fff; cursor: pointer; transition: transform .2s, box-shadow .2s;
        box-shadow: 0 8px 22px rgba(33,150,243,.35);
      }
      .overlay button:hover:enabled { transform: translateY(-1px); box-shadow: 0 12px 28px rgba(33,150,243,.4); }
      .overlay button:disabled { opacity: .6; cursor: default; box-shadow: none; }
      .overlay button.small{ padding:.35rem .75rem; font-size:.8rem; }

      /* Center blurb */
      .center-blurb { position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%); z-index: 12;
        background: rgba(15,23,42,.7); border: 1px solid rgba(255,99,71,.5); border-radius: .85rem; padding: .85rem 1.1rem;
        font-weight: 600; letter-spacing: .015em; box-shadow: 0 14px 40px rgba(0,0,0,.35); text-align: center; }

      /* Red simulate button */
      .btn-red { background: linear-gradient(120deg,#ef4444,#dc2626) !important; border-color: rgba(255,99,71,.55) !important; color: #fff !important;
        box-shadow: 0 10px 24px rgba(239,68,68,.45) !important; }
      .btn-red:hover:enabled { box-shadow: 0 14px 28px rgba(239,68,68,.55) !important; }
      .btn-pulse { animation: pulseGlow 1.2s ease-in-out infinite; }
      @keyframes pulseGlow { 0%{ box-shadow: 0 0 0 0 rgba(239,68,68,.6);} 70%{ box-shadow: 0 0 0 12px rgba(239,68,68,0);} 100%{ box-shadow: 0 0 0 0 rgba(239,68,68,0);} }

      .credits { position: absolute; bottom: 1rem; right: 1rem; font-size: .8rem; color: rgba(220,230,244,.7); background: rgba(15,23,42,.65);
        padding: .4rem .75rem; border-radius: 999px; border: 1px solid rgba(100,116,139,.4); backdrop-filter: blur(4px); }
    </style>
  </head>
  <body>
    <div class="overlay">
      <h1>Impact Simulator!</h1>
      <p>Follow along as your asteroid strikes Earth. View mitigation strategies and impacts on human life.</p>
      <p> Click anywhere on the globe to view the impact at your chosen destination.</p>
      <div style="font-size:.85rem; color:#fcd34d; font-weight:500;">Asteroid: <span id="selectedAsteroidLabel">Default profile</span></div>
      <div id="selectedAsteroidStats" style="font-size:.78rem; color:#9ca3af;">Energy ~0.4 PJ · Diameter ~20 m</div>
      <div style="display:flex; gap:.5rem; flex-wrap:wrap; margin-top:.35rem">
        <button id="launchMeteor" type="button" class="btn-red" disabled>Simulate</button>
        <button id="returnToSelection" type="button" class="small">Back to Selection</button>
        <button id="pickImpact" type="button" title="Click on the globe to set the impact point">Pick Impact</button>
      </div>
      <div style="display:flex; align-items:center; gap:.5rem; font-size:.85rem; margin-top:.35rem">
        <strong style="font-weight:600">Impact:</strong>
        <span id="impactDisplay">--</span>
      </div>
      <div style="display:flex; align-items:center; gap:.6rem; margin-top:.35rem">
        <label for="impactAngle" style="font-size:.85rem; color:#c8d6e5">Impact angle:</label>
        <input id="impactAngle" type="range" min="0" max="85" step="1" value="30" style="flex:1" />
        <span id="impactAngleVal" style="min-width:2.5rem; text-align:right; font-variant-tabular-nums:tabular-nums">30°</span>
      </div>
      <div style="display:flex; align-items:center; gap:.6rem; margin-top:.35rem">
        <label for="speedMultiplier" style="font-size:.85rem; color:#c8d6e5">Speed:</label>
        <input id="speedMultiplier" type="range" min="0.2" max="5" step="0.1" value="1.0" style="flex:1" />
        <span id="speedMultiplierVal" style="min-width:2.5rem; text-align:right; font-variant-tabular-nums:tabular-nums">1.0×</span>
      </div>
      <div id="devPanel" style="display:none; margin-top:.75rem;">
        <div style="font-size:.8rem; opacity:.9; margin: .25rem 0 .4rem 0;">Captured camera code:</div>
        <pre id="devCameraCode" style="margin:0; padding:.75rem; background:rgba(2,8,23,.6); border:1px solid rgba(125,211,252,.25); border-radius:.5rem; overflow:auto; max-height:10rem;"></pre>
        <div style="display:flex; gap:.5rem; margin-top:.5rem;">
          <button id="copyCameraCode" type="button">Copy</button>
          <button id="useAsStart" type="button" title="Use this camera view as the initial camera on load">Use as Start</button>
          <button id="clearStart" type="button" title="Clear saved start camera">Clear Saved Start</button>
        </div>
      </div>
    </div>

    <!-- Center prompt shown on first load until an impact point is chosen -->
    <div id="centerBlurb" class="center-blurb">Choose impact location</div>

    <div id="cesiumContainer"></div>
    <div class="credits">Powered by CesiumJS + OpenStreetMap imagery</div>

    <script>
      window.CESIUM_BASE_URL = "./node_modules/cesium/Build/Cesium/";
      window.CESIUM_ION_TOKEN = "__CESIUM_ION_TOKEN__";
    </script>
    <script src="./node_modules/cesium/Build/Cesium/Cesium.js"></script>
    <script>
      (function () {
        if (!window.Cesium) { console.error("Cesium failed to load. Check the script path."); return; }
        Cesium.buildModuleUrl.setBaseUrl(window.CESIUM_BASE_URL);

        const ionToken =
          typeof window.CESIUM_ION_TOKEN === "string" &&
          window.CESIUM_ION_TOKEN.trim() !== "" &&
          window.CESIUM_ION_TOKEN !== "__CESIUM_ION_TOKEN__"
            ? window.CESIUM_ION_TOKEN : null;
        if (ionToken) Cesium.Ion.defaultAccessToken = ionToken;

        const viewerOptions = { infoBox: false };
        if (!ionToken) {
          viewerOptions.imageryProvider = new Cesium.OpenStreetMapImageryProvider({ url: "https://tile.openstreetmap.org/" });
          viewerOptions.terrainProvider = new Cesium.EllipsoidTerrainProvider();
        }

        Cesium.Math.setRandomNumberSeed(1234);
        const viewer = new Cesium.Viewer("cesiumContainer", viewerOptions);
        viewer.clock.shouldAnimate = false;

        // === Dev camera loader: apply saved start camera if present ===
        try {
          const saved = localStorage.getItem("devCameraStart");
          if (saved) {
            const cfg = JSON.parse(saved);
            viewer.scene.camera.setView(cfg);
          }
        } catch (e) { /* ignore */ }

        // ==== Config ====
        const CITIES = {
          chicago: {
            lat: 41.8832,
            lon: -87.6324,
            cameraStart: {
              destination: { lon: -91.527187, lat: 5.866008, height: 14638136.82 },
              orientation: { heading: 6.283185, pitch: -1.570640, roll: 0.000000 }
            }
          }
        };
        const ASTEROIDS = {
          chelyabinskLike: { joules: 4.0e14, sizeMeters: 20 },
          a1: { joules: 1.2e15, sizeMeters: 45 },
          a2: { joules: 6.0e14, sizeMeters: 30 },
          a3: { joules: 2.5e15, sizeMeters: 80 },
          a4: { joules: 8.0e14, sizeMeters: 35 },
        };
        const JOULE_RADIUS_SCALE = 1e-9;

        const METEOR = {
          startLon: -120.0, startLat: 80.0, startAlt: 900000.0,
          targetCity: "chicago",
          asteroidId: "chelyabinskLike",
          endLon: null, endLat: null, endAlt: 1000.0,
          flightSeconds: 20, trailSeconds: 20,
          useModel: false, modelUri: "/models/asteroid.glb",
          tailExtensionFactor: 3.0,              // how many path-lengths to extend backward before the animation
          tailMaxPoints: 600,                    // cap the stored tail to limit memory
          tailAddMinDistance: 5000               // meters between recorded samples along the tail
        };

        const STORAGE_KEY = 'mpact:selectedAsteroid';
        let storedSelection = null;
        try {
          const raw = sessionStorage.getItem(STORAGE_KEY);
          if (raw) storedSelection = JSON.parse(raw);
        } catch (err) {
          console.warn('Unable to parse stored asteroid selection:', err);
        }
        if (storedSelection) {
          sessionStorage.removeItem(STORAGE_KEY);
          if (storedSelection.meteorProfileId) {
            METEOR.asteroidId = storedSelection.meteorProfileId;
            ASTEROIDS[storedSelection.meteorProfileId] = {
              joules: storedSelection.energyJoules || ASTEROIDS.chelyabinskLike.joules,
              sizeMeters: storedSelection.sizeMeters || ASTEROIDS.chelyabinskLike.sizeMeters,
            };
          }
          if (storedSelection.targetCity && CITIES[storedSelection.targetCity]) {
            METEOR.targetCity = storedSelection.targetCity;
          }
          const labelEl = document.getElementById('selectedAsteroidLabel');
          if (labelEl) {
            labelEl.textContent = storedSelection.name || storedSelection.meteorProfileId || 'Custom';
          }
          const statsEl = document.getElementById('selectedAsteroidStats');
          if (statsEl) {
            const energyPJ = storedSelection.energyJoules ? (storedSelection.energyJoules).toFixed(2) : '0.40';
            const size = storedSelection.sizeMeters ? storedSelection.sizeMeters.toFixed(0) : '20';
            statsEl.textContent = `Energy ~${energyPJ} Megatons · Diameter ~${size} m`;
          }
        } else {
          const labelEl = document.getElementById('selectedAsteroidLabel');
          if (labelEl) labelEl.textContent = 'Default profile';
          const statsEl = document.getElementById('selectedAsteroidStats');
          if (statsEl) statsEl.textContent = 'Energy ~0.4 Megatons · Diameter ~20 m';
        }
        const targetCity = CITIES[METEOR.targetCity];
        METEOR.endLon = targetCity ? targetCity.lon : -90.0;
        METEOR.endLat = targetCity ? targetCity.lat : 33.0;
        // reflect defaults in UI
        setTimeout(() => {
          const el = document.getElementById('impactDisplay');
          if (el) el.textContent = `${METEOR.endLat.toFixed(4)}°, ${METEOR.endLon.toFixed(4)}°`;
        }, 0);

        // === Curved path helper (great-circle + altitude profile) ==========
        function buildGeodesicPathSamples(opts) {
          const {
            startLon, startLat, startAlt,
            endLon, endLat, endAlt,
            flightSeconds, numPoints = 96,
            startTime = Cesium.JulianDate.now(),
            altExponent = 1.15,
          } = opts;

          const startCarto = Cesium.Cartographic.fromDegrees(startLon, startLat);
          const endCarto   = Cesium.Cartographic.fromDegrees(endLon, endLat);
          const geodesic   = new Cesium.EllipsoidGeodesic(startCarto, endCarto);

          const samples = new Cesium.SampledPositionProperty();
          for (let i = 0; i < numPoints; i++) {
            const t = i / (numPoints - 1);
            const when = Cesium.JulianDate.addSeconds(startTime, t * flightSeconds, new Cesium.JulianDate());
            const p = geodesic.interpolateUsingFraction(t);

            // Altitude profile
            const h = startAlt * Math.pow(1 - t, altExponent) + endAlt * (1 - Math.pow(1 - t, altExponent));

            const pos = Cesium.Cartesian3.fromRadians(p.longitude, p.latitude, h);
            samples.addSample(when, pos);
          }

          samples.setInterpolationOptions({
            interpolationDegree: 2,
            interpolationAlgorithm: Cesium.LagrangePolynomialApproximation,
          });

          return { samples, geodesic, startCarto, endCarto };
        }
        // ===================================================================

        function makeParticleImage(size = 32) {
          const canvas = document.createElement("canvas");
          canvas.width = size; canvas.height = size;
          const ctx = canvas.getContext("2d");
          const g = ctx.createRadialGradient(size/2, size/2, 1, size/2, size/2, size/2);
          g.addColorStop(0.0,"rgba(255,255,255,1)");
          g.addColorStop(0.25,"rgba(255,210,0,0.95)");
          g.addColorStop(1.0,"rgba(255,120,0,0)");
          ctx.fillStyle = g;
          ctx.beginPath(); ctx.arc(size/2, size/2, size/2, 0, Math.PI*2); ctx.fill();
          return canvas;
        }

        // NEW: simple crosshair image for the chosen impact point
        function makeCrossImage(size = 40, color = 'rgba(255,80,80,1)') {
          const c = document.createElement('canvas');
          c.width = size; c.height = size;
          const x = c.getContext('2d');
          x.strokeStyle = color;
          x.lineWidth = Math.max(2, size * 0.08);
          x.lineCap = 'round';
          const m = size * 0.2;
          x.beginPath();
          x.moveTo(m, size/2); x.lineTo(size-m, size/2);
          x.moveTo(size/2, m); x.lineTo(size/2, size-m);
          x.stroke();
          return c;
        }

        // Helper to apply a camera setView using degrees-based config
        function applyCameraFromConfig(cfg) {
          if (!cfg) return;
          viewer.scene.camera.setView({
            destination: Cesium.Cartesian3.fromDegrees(
              cfg.destination.lon,
              cfg.destination.lat,
              cfg.destination.height
            ),
            orientation: cfg.orientation
          });
        }

        const launchButton = document.getElementById("launchMeteor");
        const returnButton = document.getElementById("returnToSelection");
        returnButton?.addEventListener('click', () => { window.location.href = '/'; });
        const angleSlider = document.getElementById("impactAngle");
        const angleVal    = document.getElementById("impactAngleVal");
        let impactAngleDeg = Number(angleSlider?.value || 30);
        angleSlider?.addEventListener("input", () => {
          impactAngleDeg = Number(angleSlider.value);
          angleVal.textContent = `${impactAngleDeg}°`;
        });
        const speedSlider = document.getElementById("speedMultiplier");
        const speedVal    = document.getElementById("speedMultiplierVal");
        let speedMult = Number(speedSlider?.value || 1.0);
        speedSlider?.addEventListener("input", () => {
          speedMult = Number(speedSlider.value);
          speedVal.textContent = `${(speedMult * 32000).toFixed(0)} mph`;
          viewer.clock.multiplier = speedMult;
        });

        let meteorActive = false;
        let impactCircleEntities = [];
        let impactCircleTimers = [];
        let epicenterSpheres = [];
        let activeTrail = null;
        let trajectoryEntity = null; // persistent path shown until next run
        let trajectoryPositions = []; // updated in real time to extend the trail
        let impactCrossEntity = null; // NEW crosshair marker

        function clearEpicenterSpheres() {
          epicenterSpheres.forEach((e) => viewer.entities.remove(e));
          epicenterSpheres = [];
        }
        function createEpicenterSpheres() {
          clearEpicenterSpheres();
          const radii = [60, 120, 200, 300]; // very small concentric spheres (meters)
          const pos = Cesium.Cartesian3.fromDegrees(METEOR.endLon, METEOR.endLat, METEOR.endAlt);
          radii.forEach((r, i) => {
            const ent = viewer.entities.add({
              position: pos,
              ellipsoid: {
                radii: new Cesium.Cartesian3(r, r, r),
                material: Cesium.Color.ORANGE.withAlpha(0.22 + i * 0.12),
                outline: true,
                outlineColor: Cesium.Color.ORANGE.withAlpha(0.65 + i * 0.06),
                stackPartitions: 16,
                slicePartitions: 16,
              },
            });
            epicenterSpheres.push(ent);
          });
        }

        // NEW: create/update a crosshair billboard at the chosen point
        function updateImpactCross() {
          if (impactCrossEntity) {
            viewer.entities.remove(impactCrossEntity);
            impactCrossEntity = null;
          }
          impactCrossEntity = viewer.entities.add({
            position: Cesium.Cartesian3.fromDegrees(METEOR.endLon, METEOR.endLat, 0.0),
            billboard: {
              image: makeCrossImage(44),
              verticalOrigin: Cesium.VerticalOrigin.CENTER,
              horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
              disableDepthTestDistance: Number.POSITIVE_INFINITY,
              scaleByDistance: new Cesium.NearFarScalar(500.0, 1.2, 5000000.0, 0.6)
            }
          });
        }

        // NEW: bake the flown trajectory into a static polyline that persists
        function bakeFinalTrajectory() {
          if (trajectoryEntity) {
            viewer.entities.remove(trajectoryEntity);
            trajectoryEntity = null;
          }
          if (trajectoryPositions.length >= 2) {
            trajectoryEntity = viewer.entities.add({
              polyline: {
                positions: trajectoryPositions.slice(),
                width: 6,
                material: new Cesium.PolylineGlowMaterialProperty({
                  color: Cesium.Color.ORANGE.withAlpha(0.9),
                  glowPower: 0.15
                })
              }
            });
          }
        }

        function startMeteorRun() {
          if (!launchButton) { console.error("Simulate button is missing."); return; }
          if (meteorActive) return;

          // Cleanup from prior runs (keep epicenter spheres & crosshair until new pick)
          impactCircleTimers.forEach((id) => window.clearTimeout(id));
          impactCircleTimers = [];
          impactCircleEntities.forEach((e) => viewer.entities.remove(e));
          impactCircleEntities = [];
          if (activeTrail) { viewer.scene.primitives.remove(activeTrail); activeTrail = null; }
          if (trajectoryEntity) { viewer.entities.remove(trajectoryEntity); trajectoryEntity = null; } // clear previous baked path ONLY when a new sim starts
          trajectoryPositions = [];

          launchButton.disabled = true;
          launchButton.classList.remove('btn-pulse');

          const asteroidProfile = ASTEROIDS[METEOR.asteroidId];
          const impactRadius = asteroidProfile
            ? Math.max(asteroidProfile.sizeMeters * 500.0, asteroidProfile.joules * JOULE_RADIUS_SCALE)
            : 50000.0;

          meteorActive = true;
          if (pickBtn) pickBtn.disabled = true;

          const startTime = Cesium.JulianDate.now();
          const stopTime = Cesium.JulianDate.addSeconds(startTime, METEOR.flightSeconds, new Cesium.JulianDate());

          viewer.clock.startTime = startTime.clone();
          viewer.clock.stopTime = stopTime.clone();
          viewer.clock.currentTime = startTime.clone();
          viewer.clock.clockRange = Cesium.ClockRange.CLAMPED;
          viewer.clock.multiplier = speedMult;
          viewer.clock.shouldAnimate = false;

          // === Build the curved path (trajectory) ==========================
          const tmpGeodesic = new Cesium.EllipsoidGeodesic(
            Cesium.Cartographic.fromDegrees(METEOR.startLon, METEOR.startLat),
            Cesium.Cartographic.fromDegrees(METEOR.endLon, METEOR.endLat)
          );
          const L = tmpGeodesic.surfaceDistance; // meters
          const angleRad = Cesium.Math.toRadians(Math.min(85, Math.max(0, impactAngleDeg)));

          // Choose start altitude so that dh/ds at end matches -tan(angle)
          const startAltForAngle = METEOR.endAlt + L * Math.tan(angleRad);

          const {
            samples: positionProperty,
            startCarto,
            endCarto,
          } = buildGeodesicPathSamples({
            startLon: METEOR.startLon, startLat: METEOR.startLat, startAlt: startAltForAngle,
            endLon: METEOR.endLon,     endLat: METEOR.endLat,     endAlt: METEOR.endAlt,
            flightSeconds: METEOR.flightSeconds,
            numPoints: 128,
            startTime,
            altExponent: 1 // linear to satisfy slope requirement at impact
          });

          const startCartesian = Cesium.Cartesian3.fromRadians(
            startCarto.longitude,
            startCarto.latitude,
            startAltForAngle
          );
          const endCartesian = Cesium.Cartesian3.fromRadians(
            endCarto.longitude,
            endCarto.latitude,
            METEOR.endAlt
          );

          const tailExtensionFactor = METEOR.tailExtensionFactor || 3.0;
          const tailVector = Cesium.Cartesian3.subtract(
            startCartesian,
            endCartesian,
            new Cesium.Cartesian3()
          );
          Cesium.Cartesian3.multiplyByScalar(tailVector, tailExtensionFactor, tailVector);
          const tailCartesian = Cesium.Cartesian3.add(
            startCartesian,
            tailVector,
            new Cesium.Cartesian3()
          );

          trajectoryPositions = [
            Cesium.Cartesian3.clone(startCartesian),
          ];

          const baseEntity = {
            position: positionProperty,
            orientation: new Cesium.VelocityOrientationProperty(positionProperty),
            path: {
              resolution: 1,
              leadTime: 0,
              trailTime: METEOR.trailSeconds,
              material: new Cesium.PolylineGlowMaterialProperty({ color: Cesium.Color.ORANGE, glowPower: 0.25 }),
              width: 8,
            },
          };

          const meteorEntity = viewer.entities.add(
            METEOR.useModel
              ? { ...baseEntity, model: { uri: METEOR.modelUri, minimumPixelSize: 32, scale: 1.0 } }
              : { ...baseEntity, point: { pixelSize: 12, color: Cesium.Color.YELLOW.withAlpha(0.95), outlineColor: Cesium.Color.ORANGE, outlineWidth: 2 } }
          );

          // Particle plume attached to meteor orientation
          const trailDuration = METEOR.flightSeconds + 20;
          const plume = new Cesium.ParticleSystem({
            image: makeParticleImage(32),
            startScale: 1.0, endScale: 0.5, emissionRate: 140,
            particleLife: trailDuration, lifetime: trailDuration, speed: 800.0,
            emitter: new Cesium.ConeEmitter(Cesium.Math.toRadians(10)), sizeInMeters: true,
          });
          viewer.scene.primitives.add(plume);
          activeTrail = plume;

          let burstTimeoutId = null;
          let burstPrimitive = null;
          let preRenderCallback;

          const finalize = () => {
            if (burstTimeoutId !== null) { window.clearTimeout(burstTimeoutId); burstTimeoutId = null; }
            viewer.scene.preRender.removeEventListener(preRenderCallback);
            if (burstPrimitive) { viewer.scene.primitives.remove(burstPrimitive); burstPrimitive = null; }
            viewer.entities.remove(meteorEntity);
            viewer.clock.shouldAnimate = false;
            meteorActive = false;
            if (pickBtn) pickBtn.disabled = false;
            launchButton.disabled = false;
            launchButton.classList.add('btn-pulse');
            // Ensure spheres are present at the epicenter
            createEpicenterSpheres();
          };

          const rotationScratch = new Cesium.Matrix3();
          const flipMatrix = Cesium.Matrix3.fromRotationY(Math.PI, new Cesium.Matrix3());
          const plumeMatrix = new Cesium.Matrix4();

          preRenderCallback = function (_scene, time) {
            const now = time || viewer.clock.currentTime;
            const position = baseEntity.position.getValue(now);
            if (!position) return;

            const orientation = meteorEntity.orientation.getValue(now);
            if (orientation) {
              Cesium.Matrix3.fromQuaternion(orientation, rotationScratch);
              Cesium.Matrix3.multiply(rotationScratch, flipMatrix, rotationScratch);
              Cesium.Matrix4.fromRotationTranslation(rotationScratch, position, plumeMatrix);
              plume.modelMatrix = plumeMatrix;
            } else {
              Cesium.Transforms.eastNorthUpToFixedFrame(position, undefined, plumeMatrix);
              plume.modelMatrix = plumeMatrix;
            }

            const lastRecorded = trajectoryPositions[trajectoryPositions.length - 1];
            const minDistance = METEOR.tailAddMinDistance || 5000;
            const shouldAdd = !lastRecorded || Cesium.Cartesian3.distance(position, lastRecorded) > minDistance;
            if (shouldAdd) {
              trajectoryPositions.push(Cesium.Cartesian3.clone(position));
              const maxPoints = METEOR.tailMaxPoints || 600;
              if (trajectoryPositions.length > maxPoints) {
                const excess = trajectoryPositions.length - maxPoints;
                trajectoryPositions.splice(1, excess); // preserve tail anchor at index 0
              }
            }

            const cartographic = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);
            const lowAltitude = cartographic ? cartographic.height < 1500.0 : false;
            const reachedEnd = Cesium.JulianDate.greaterThanOrEquals(now, stopTime);

            if (reachedEnd || lowAltitude) {
              viewer.scene.preRender.removeEventListener(preRenderCallback);

              meteorEntity.show = false;
              viewer.clock.currentTime = stopTime.clone();

              const finalRecorded = trajectoryPositions[trajectoryPositions.length - 1];
              if (!finalRecorded || !Cesium.Cartesian3.equalsEpsilon(endCartesian, finalRecorded, Cesium.Math.EPSILON3)) {
                trajectoryPositions.push(Cesium.Cartesian3.clone(endCartesian));
              }

              // NEW: bake the full flown path into a persistent polyline
              bakeFinalTrajectory();

              const impactCartesian = Cesium.Cartesian3.fromDegrees(METEOR.endLon, METEOR.endLat, 10.0);
              burstPrimitive = new Cesium.ParticleSystem({
                image: makeParticleImage(48), startScale: 2.0, endScale: 6.0,
                emissionRate: 0, lifetime: 1.6, particleLife: 0.8, speed: 120.0, sizeInMeters: true,
                emitter: new Cesium.SphereEmitter(80.0),
                modelMatrix: Cesium.Transforms.eastNorthUpToFixedFrame(impactCartesian),
                bursts: [ new Cesium.ParticleBurst({ time: 0.0, minimum: 300, maximum: 300 }) ],
              });
              viewer.scene.primitives.add(burstPrimitive);

              // Expanding 2D shock rings (keep existing visual)
              if (impactCircleEntities.length === 0) {
                const circleCount = 5, delayMs = 1000;
                const radiusStep = impactRadius / circleCount;
                for (let i = 0; i < circleCount; i++) {
                  const timerId = window.setTimeout(() => {
                    const radius = radiusStep * (i + 1);
                    const circle = viewer.entities.add({
                      position: Cesium.Cartesian3.fromDegrees(METEOR.endLon, METEOR.endLat, METEOR.endAlt),
                      ellipse: {
                        semiMajorAxis: radius, semiMinorAxis: radius, height: METEOR.endAlt,
                        material: Cesium.Color.RED.withAlpha(0.25 + i * 0.12),
                        outline: true, outlineColor: Cesium.Color.RED.withAlpha(0.6 + i * 0.08), outlineWidth: 3,
                      },
                    });
                    impactCircleEntities.push(circle);
                  }, i * delayMs);
                  impactCircleTimers.push(timerId);
                }
              }

              burstTimeoutId = window.setTimeout(finalize, 2000);
            }
          };

          viewer.scene.preRender.addEventListener(preRenderCallback);
          viewer.clock.shouldAnimate = true; // Go!
        }

        // === Impact picking (click anywhere to set endLon/Lat) ===
        const pickBtn = document.getElementById("pickImpact");
        const impactDisp = document.getElementById("impactDisplay");
        const centerBlurb = document.getElementById("centerBlurb");

        function updateImpactDisplay() {
          if (impactDisp) impactDisp.textContent = `${METEOR.endLat.toFixed(4)}°, ${METEOR.endLon.toFixed(4)}°`;
        }
        updateImpactDisplay();

        // Start in picking mode immediately
        let pickingImpact = true;
        pickBtn && (pickBtn.textContent = "Click on globe…");
        viewer.canvas.style.cursor = "crosshair";

        const clickHandler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
        pickBtn?.addEventListener("click", () => {
          pickingImpact = !pickingImpact;
          pickBtn.textContent = pickingImpact ? "Click on globe…" : "Pick Impact";
          viewer.canvas.style.cursor = pickingImpact ? "crosshair" : "";
          if (pickingImpact && centerBlurb) centerBlurb.style.display = 'block';
        });

        clickHandler.setInputAction((evt) => {
          if (!pickingImpact) return;
          const ray = viewer.scene.camera.getPickRay(evt.position);
          const cart = viewer.scene.globe.pick(ray, viewer.scene);
          if (!cart) { pickingImpact = false; pickBtn.textContent = "Pick Impact"; viewer.canvas.style.cursor = ""; return; }
          const carto = Cesium.Cartographic.fromCartesian(cart);
          METEOR.endLon = Cesium.Math.toDegrees(carto.longitude);
          METEOR.endLat = Cesium.Math.toDegrees(carto.latitude);
          updateImpactDisplay();

          // Create/update small concentric spheres at epicenter + crosshair
          createEpicenterSpheres();
          updateImpactCross(); // NEW

          // UI feedback: enable Simulate button and hide center blurb
          if (centerBlurb) { centerBlurb.textContent != null; setTimeout(() => (centerBlurb.style.display = 'none'), 600); }
          if (launchButton) { launchButton.disabled = false; launchButton.classList.add('btn-pulse'); }

          pickingImpact = false;
          pickBtn && (pickBtn.textContent = "Pick Impact");
          viewer.canvas.style.cursor = "";
        }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
        // === End impact picking ===

        if (launchButton) launchButton.addEventListener("click", startMeteorRun);
      })();
    </script>
  </body>
</html>
