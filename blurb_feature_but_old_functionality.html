<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Globe Simulator</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="./node_modules/cesium/Build/Cesium/Widgets/widgets.css" />

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bitcount+Single+Ink:wght@100..900&display=swap" rel="stylesheet">

    <style>

      
      :root { color-scheme: dark; font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; }
      body { margin: 0; background: #0b1a2a; color: #f1f3f5; overflow: hidden; }
      #cesiumContainer { position: absolute; inset: 0; }
      .overlay {
        position: absolute; top: 1.5rem; left: 1.5rem; display: flex; flex-direction: column; gap: 0.5rem; z-index: 10;
        background: rgba(6,17,32,.8); border: 1px solid rgba(110,191,244,.35); border-radius: .75rem; padding: 1rem 1.25rem;
        max-width: 20rem; backdrop-filter: blur(6px); box-shadow: 0 12px 35px rgba(0,0,0,.35);
      }
      .overlay h1 { margin: 0; font-size: 1.8rem; color: #cf6de2; font-family: 'Bitcount Single Ink', sans-serif;}
      .overlay p { margin: 0; font-size: .95rem; line-height: 1.45; color: #c8d6e5; }
      .overlay button {
        margin-top: .75rem; padding: .5rem 1.1rem; font-size: .85rem; border: 1px solid rgba(125,211,252,.45); border-radius: 999px;
        background: linear-gradient(120deg,#1d8cf8,#935ade); color: #fff; cursor: pointer; transition: transform .2s, box-shadow .2s;
        box-shadow: 0 8px 22px rgba(33,150,243,.35);
      }
      .overlay button:hover:enabled { transform: translateY(-1px); box-shadow: 0 12px 28px rgba(33,150,243,.4); }
      .overlay button:disabled { opacity: .6; cursor: default; box-shadow: none; }
      .overlay button.small{ padding:.35rem .75rem; font-size:.8rem; }
      #cityView {
        background: linear-gradient(120deg,#4b5563,#1f2937);
        border-color: rgba(148,163,184,.45);
        box-shadow: none;
        color: #e5e7eb;
      }
      #cityView.btn-ready {
        background: linear-gradient(120deg,#1d8cf8,#935ade);
        border-color: rgba(125,211,252,.45);
        color: #fff;
        box-shadow: 0 8px 22px rgba(33,150,243,.35);
      }
      #cityView.btn-ready:hover:enabled {
        box-shadow: 0 12px 28px rgba(33,150,243,.4);
      }

      /* Center blurb */
      .center-blurb { position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%); z-index: 12;
        background: rgba(15,23,42,.7); border: 1px solid rgba(255,99,71,.5); border-radius: .85rem; padding: .85rem 1.1rem;
        font-weight: 600; letter-spacing: .015em; box-shadow: 0 14px 40px rgba(0,0,0,.35); text-align: center; }
      /* allow clicks to pass through the center blurb overlay */
      .center-blurb { pointer-events: none; }

      /* Red simulate button */
      .btn-red { background: linear-gradient(120deg,#ef4444,#dc2626) !important; border-color: rgba(255,99,71,.55) !important; color: #fff !important;
        box-shadow: 0 10px 24px rgba(239,68,68,.45) !important; }
      .btn-red:hover:enabled { box-shadow: 0 14px 28px rgba(239,68,68,.55) !important; }
      .btn-pulse { animation: pulseGlow 1.2s ease-in-out infinite; }
      @keyframes pulseGlow { 0%{ box-shadow: 0 0 0 0 rgba(239,68,68,.6);} 70%{ box-shadow: 0 0 0 12px rgba(239,68,68,0);} 100%{ box-shadow: 0 0 0 0 rgba(239,68,68,0);} }

      .credits { position: absolute; bottom: 1rem; right: 1rem; font-size: .8rem; color: rgba(220,230,244,.7); background: rgba(15,23,42,.65);
        padding: .4rem .75rem; border-radius: 999px; border: 1px solid rgba(100,116,139,.4); backdrop-filter: blur(4px); }
  
      .pop-blurb.hidden { display: none; }
      .pop-blurb.water { border-left-color: #3b82f6; } /* blue */
      .pop-blurb.land  { border-left-color: #ef4444; } /* red */

      .pb-content { padding: 0.9rem 1rem 1rem 1rem; }
      .pb-title   { font-weight: 700; margin-bottom: .35rem; font-size: 1.05rem; }
      .pb-body    { color: #c8d6e5; font-size: .92rem; line-height: 1.4; }
      .pb-actions { display:flex; gap:.5rem; margin-top:.7rem; }
      #pbRun {
        padding: .45rem .9rem; border-radius: 999px; border: 1px solid rgba(125,211,252,.45);
        background: linear-gradient(120deg,#1d8cf8,#935ade); color: #fff; cursor: pointer;
      }
      #pbClose.secondary {
        padding: .45rem .9rem; border-radius: 999px; border: 1px solid rgba(100,116,139,.45);
        background: rgba(30,41,59,.85); color: #e5e7eb; cursor: pointer;
      }
      @keyframes slideUp { from { transform: translateY(8px); opacity: .0; } to { transform: translateY(0); opacity: 1; } }
      /* Right-side impact panel */
      .side-panel {
        position: absolute;
        top: 1rem; right: 1rem; bottom: 1rem;
        width: 420px;            /* make it big; adjust to taste */
        max-width: 48vw;         /* responsive */
        z-index: 20;
        display: flex;
        flex-direction: column;
        border: 1px solid rgba(148,163,184,.35);
        border-left: 8px solid #475569; /* default edge; color changes with land/water */
        border-radius: .9rem;
        background: rgba(10,17,28,.92);
        backdrop-filter: blur(6px);
        box-shadow: 0 14px 40px rgba(0,0,0,.45);
        animation: slideIn .22s ease-out;
      }
      .side-panel.hidden { display: none; }
      .side-panel.water  { border-left-color: #3b82f6; } /* blue edge */
      .side-panel.land   { border-left-color: #ef4444; } /* red edge */

      .sp-header {
        display: flex; align-items: center; justify-content: space-between;
        padding: .85rem 1rem;
        border-bottom: 1px solid rgba(148,163,184,.25);
      }
      .sp-title { font-weight: 800; font-size: 1.05rem; }
      .sp-close {
        border: 1px solid rgba(100,116,139,.45);
        background: rgba(30,41,59,.85);
        color: #e5e7eb;
        border-radius: 8px;
        width: 34px; height: 34px; line-height: 32px;
        font-size: 20px; cursor: pointer;
      }

      .sp-body {
        padding: 0.9rem 1rem 1.1rem 1rem;
        overflow: auto;          /* allow long content to scroll */
        font-size: .95rem; line-height: 1.5; color: #c8d6e5;
      }

      @keyframes slideIn { from { transform: translateX(10px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }

    </style>
  </head>
  <body>
    <div class="overlay">
      <h1>Impact Simulator!</h1>
      <p>Follow along as your asteroid strikes Earth. View mitigation strategies and impacts on human life.</p>
      <p> Click anywhere on the globe to view the impact at your chosen destination.</p>
      <div style="font-size:.85rem; color:#fcd34d; font-weight:500;">Asteroid: <span id="selectedAsteroidLabel">Default profile</span></div>
      <div id="selectedAsteroidStats" style="font-size:.78rem; color:#9ca3af;">Energy ~0.4 PJ · Diameter ~20 m</div>
      <div style="display:flex; gap:.5rem; flex-wrap:wrap; margin-top:.35rem">
        <button id="launchMeteor" type="button" class="btn-red" disabled>IMPACT!</button>
        <button id="returnToSelection" type="button" class="small">Choose a New Asteroid</button>
        <button id="pickImpact" type="button" title="Click on the globe">Pick Impact</button>
        <button id="timeline" type="button" class="btn-red" disabled>See Timeline</button>
        <button id="cityView" type="button" disabled>City view</button>
      </div>
      <div style="display:flex; align-items:center; gap:.5rem; font-size:.85rem; margin-top:.35rem">
        <strong style="font-weight:600">Impact:</strong>
        <span id="impactDisplay">--</span>
      </div>
      <div style="display:flex; align-items:center; gap:.6rem; margin-top:.35rem">
        <label for="impactAngle" style="font-size:.85rem; color:#c8d6e5">Impact angle:</label>
        <input id="impactAngle" type="range" min="0" max="85" step="1" value="30" style="flex:1" />
        <span id="impactAngleVal" style="min-width:2.5rem; text-align:right; font-variant-tabular-nums:tabular-nums">30°</span>
      </div>
      <div style="display:flex; align-items:center; gap:.6rem; margin-top:.35rem">
        <label for="speedMultiplier" style="font-size:.85rem; color:#c8d6e5">Speed:</label>
        <input id="speedMultiplier" type="range" min="0.2" max="5" step="0.1" value="1.0" style="flex:1" />
        <span id="speedMultiplierVal" style="min-width:2.5rem; text-align:right; font-variant-tabular-nums:tabular-nums">1.0×</span>
      </div>
      <div id="devPanel" style="display:none; margin-top:.75rem;">
        <div style="font-size:.8rem; opacity:.9; margin: .25rem 0 .4rem 0;">Captured camera code:</div>
        <pre id="devCameraCode" style="margin:0; padding:.75rem; background:rgba(2,8,23,.6); border:1px solid rgba(125,211,252,.25); border-radius:.5rem; overflow:auto; max-height:10rem;"></pre>
        <div style="display:flex; gap:.5rem; margin-top:.5rem;">
          <button id="copyCameraCode" type="button">Copy</button>
          <button id="useAsStart" type="button" title="Use this camera view as the initial camera on load">Use as Start</button>
          <button id="clearStart" type="button" title="Clear saved start camera">Clear Saved Start</button>
        </div>
      </div>
    </div>

    <!-- Center prompt shown on first load until an impact point is chosen -->
    <div id="centerBlurb" class="center-blurb">Choose your impact location...</div>
    <!-- Side panel (appears after a pick) -->
    <div id="popBlurb" class="side-panel hidden">
      <div class="sp-header">
        <div class="sp-title" id="pbTitle"></div>
        <button id="pbClose" class="sp-close" aria-label="Close">&times;</button>
      </div>
      <div class="sp-body" id="pbBody"></div>
    </div>


    <div id="cesiumContainer"></div>
    <div class="credits">Powered by CesiumJS + OpenStreetMap imagery</div>

    <script>
      window.CESIUM_BASE_URL = "./node_modules/cesium/Build/Cesium/";
      window.CESIUM_ION_TOKEN = "__CESIUM_ION_TOKEN__";
    </script>
    <script src="./node_modules/cesium/Build/Cesium/Cesium.js"></script>
    <!-- Turf & TopoJSON from CDNs (pinned versions) -->
    <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
    <script src="https://unpkg.com/topojson-client@3.1.0/dist/topojson-client.min.js"></script>

    <script>
      (function () {
        if (!window.Cesium) { console.error("Cesium failed to load. Check the script path."); return; }
        Cesium.buildModuleUrl.setBaseUrl(window.CESIUM_BASE_URL);

        const ionToken =
          typeof window.CESIUM_ION_TOKEN === "string" &&
          window.CESIUM_ION_TOKEN.trim() !== "" &&
          window.CESIUM_ION_TOKEN !== "__CESIUM_ION_TOKEN__"
            ? window.CESIUM_ION_TOKEN : null;
        if (ionToken) Cesium.Ion.defaultAccessToken = ionToken;

        const viewerOptions = {
          infoBox: false,
          animation: false,
          timeline: false,
          geocoder: false,
          homeButton: false,
          navigationHelpButton: false,

          fullscreenButton: false,
          selectionIndicator: false,
        };
        if (!ionToken) {
          viewerOptions.imageryProvider = new Cesium.OpenStreetMapImageryProvider({ url: "https://tile.openstreetmap.org/" });
          viewerOptions.terrainProvider = new Cesium.EllipsoidTerrainProvider();
        }

        Cesium.Math.setRandomNumberSeed(1234);
        const viewer = new Cesium.Viewer("cesiumContainer", viewerOptions);
        if (ionToken) {
          Cesium.CesiumTerrainProvider.fromIonAssetId(1).then((tp) => {
            viewer.terrainProvider = tp;                 // switch to real terrain
            console.log("Cesium World Terrain ready");   // optional debug
          });
        }
        viewer.clock.shouldAnimate = false;

        // === Dev camera loader: apply saved start camera if present ===
        try {
          const saved = localStorage.getItem("devCameraStart");
          if (saved) {
            const cfg = JSON.parse(saved);
            viewer.scene.camera.setView(cfg);
          }
        } catch (e) { /* ignore */ }

        // ==== Config ====
        const CITIES = {
          chicago: {
            lat: 41.8832,
            lon: -87.6324,
            cameraStart: {
              destination: { lon: -91.527187, lat: 5.866008, height: 14638136.82 },
              orientation: { heading: 6.283185, pitch: -1.570640, roll: 0.000000 }
            }
          }
        };
        const ASTEROIDS = {
          chelyabinskLike: { joules: 4.0e14, sizeMeters: 20 },
          a1: { joules: 1.2e15, sizeMeters: 45 },
          a2: { joules: 6.0e14, sizeMeters: 30 },
          a3: { joules: 2.5e15, sizeMeters: 80 },
          a4: { joules: 8.0e14, sizeMeters: 35 },
        };
        const MAJOR_CITIES = [
          { name: "New York City", lat: 40.7128, lon: -74.0060 },
          { name: "Los Angeles", lat: 34.0522, lon: -118.2437 },
          { name: "Chicago", lat: 41.8781, lon: -87.6298 },
          { name: "London", lat: 51.5074, lon: -0.1278 },
          { name: "Paris", lat: 48.8566, lon: 2.3522 },
          { name: "Madrid", lat: 40.4168, lon: -3.7038 },
          { name: "Tokyo", lat: 35.6762, lon: 139.6503 },
          { name: "Mexico City", lat: 19.4326, lon: -99.1332 },
          { name: "Sao Paulo", lat: -23.5505, lon: -46.6333 },
          { name: "Sydney", lat: -33.8688, lon: 151.2093 },
          { name: "Cairo", lat: 30.0444, lon: 31.2357 },
          { name: "Johannesburg", lat: -26.2041, lon: 28.0473 },
        ];
        const CITY_PROXIMITY_THRESHOLD_KM = 75;
        const JOULE_RADIUS_SCALE = 1e-9;

        const METEOR = {
          startLon: -120.0, startLat: 80.0, startAlt: 900000.0,
          targetCity: "chicago",
          asteroidId: "chelyabinskLike",
          endLon: null, endLat: null, endAlt: 1000.0,
          flightSeconds: 20, trailSeconds: 20,
          useModel: false, modelUri: "/models/asteroid.glb",
          tailExtensionFactor: 3.0,              // how many path-lengths to extend backward before the animation
          tailMaxPoints: 600,                    // cap the stored tail to limit memory
          tailAddMinDistance: 5000               // meters between recorded samples along the tail
        };

        const STORAGE_KEY = 'mpact:selectedAsteroid';
        let storedSelection = null;
        try {
          const raw = sessionStorage.getItem(STORAGE_KEY);
          if (raw) storedSelection = JSON.parse(raw);
        } catch (err) {
          console.warn('Unable to parse stored asteroid selection:', err);
        }
        if (storedSelection) {
          sessionStorage.removeItem(STORAGE_KEY);
          if (storedSelection.meteorProfileId) {
            METEOR.asteroidId = storedSelection.meteorProfileId;
            ASTEROIDS[storedSelection.meteorProfileId] = {
              joules: storedSelection.energyJoules || ASTEROIDS.chelyabinskLike.joules,
              sizeMeters: storedSelection.sizeMeters || ASTEROIDS.chelyabinskLike.sizeMeters,
            };
          }
          if (storedSelection.targetCity && CITIES[storedSelection.targetCity]) {
            METEOR.targetCity = storedSelection.targetCity;
          }
          const labelEl = document.getElementById('selectedAsteroidLabel');
          if (labelEl) {
            labelEl.textContent = storedSelection.name || storedSelection.meteorProfileId || 'Custom';
          }
          const statsEl = document.getElementById('selectedAsteroidStats');
          if (statsEl) {
            const energyPJ = storedSelection.energyJoules ? (storedSelection.energyJoules).toFixed(2) : '0.40';
            const size = storedSelection.sizeMeters ? storedSelection.sizeMeters.toFixed(0) : '20';
            statsEl.textContent = `Energy ~${energyPJ} Megatons · Diameter ~${size} m`;
          }
        } else {
          const labelEl = document.getElementById('selectedAsteroidLabel');
          if (labelEl) labelEl.textContent = 'Default profile';
          const statsEl = document.getElementById('selectedAsteroidStats');
          if (statsEl) statsEl.textContent = 'Energy ~0.4 Megatons of TNT· Diameter ~20 m';
        }
        const targetCity = CITIES[METEOR.targetCity];
        METEOR.endLon = targetCity ? targetCity.lon : -90.0;
        METEOR.endLat = targetCity ? targetCity.lat : 33.0;
        // reflect defaults in UI
        setTimeout(() => {
          const el = document.getElementById('impactDisplay');
          if (el) el.textContent = `${METEOR.endLat.toFixed(4)}°, ${METEOR.endLon.toFixed(4)}°`;
        }, 0);

        // === Curved path helper (great-circle + altitude profile) ==========
        function buildGeodesicPathSamples(opts) {
          const {
            startLon, startLat, startAlt,
            endLon, endLat, endAlt,
            flightSeconds, numPoints = 96,
            startTime = Cesium.JulianDate.now(),
            altExponent = 1.15,
          } = opts;

          const startCarto = Cesium.Cartographic.fromDegrees(startLon, startLat);
          const endCarto   = Cesium.Cartographic.fromDegrees(endLon, endLat);
          const geodesic   = new Cesium.EllipsoidGeodesic(startCarto, endCarto);

          const samples = new Cesium.SampledPositionProperty();
          for (let i = 0; i < numPoints; i++) {
            const t = i / (numPoints - 1);
            const when = Cesium.JulianDate.addSeconds(startTime, t * flightSeconds, new Cesium.JulianDate());
            const p = geodesic.interpolateUsingFraction(t);

            // Altitude profile
            const h = startAlt * Math.pow(1 - t, altExponent) + endAlt * (1 - Math.pow(1 - t, altExponent));

            const pos = Cesium.Cartesian3.fromRadians(p.longitude, p.latitude, h);
            samples.addSample(when, pos);
          }

          samples.setInterpolationOptions({
            interpolationDegree: 2,
            interpolationAlgorithm: Cesium.LagrangePolynomialApproximation,
          });

          return { samples, geodesic, startCarto, endCarto };
        }
        // ===================================================================

        function makeParticleImage(size = 32) {
          const canvas = document.createElement("canvas");
          canvas.width = size; canvas.height = size;
          const ctx = canvas.getContext("2d");
          const g = ctx.createRadialGradient(size/2, size/2, 1, size/2, size/2, size/2);
          g.addColorStop(0.0,"rgba(255,255,255,1)");
          g.addColorStop(0.25,"rgba(255,210,0,0.95)");
          g.addColorStop(1.0,"rgba(255,120,0,0)");
          ctx.fillStyle = g;
          ctx.beginPath(); ctx.arc(size/2, size/2, size/2, 0, Math.PI*2); ctx.fill();
          return canvas;
        }

        // NEW: simple crosshair image for the chosen impact point
        function makeCrossImage(size = 40, color = 'rgba(255,80,80,1)') {
          const c = document.createElement('canvas');
          c.width = size; c.height = size;
          const x = c.getContext('2d');
          x.strokeStyle = color;
          x.lineWidth = Math.max(2, size * 0.08);
          x.lineCap = 'round';
          const m = size * 0.2;
          x.beginPath();
          x.moveTo(m, size/2); x.lineTo(size-m, size/2);
          x.moveTo(size/2, m); x.lineTo(size/2, size-m);
          x.stroke();
          return c;
        }
        // ---- Right-side panel helpers (no run button) ----------------------------
        const _blurb = {
          el: null, title: null, body: null, closeBtn: null,
        };

        function _initBlurbRefs() {
          if (_blurb.el) return;
          _blurb.el     = document.getElementById('popBlurb');
          _blurb.title  = document.getElementById('pbTitle');
          _blurb.body   = document.getElementById('pbBody');
          _blurb.closeBtn = document.getElementById('pbClose');
          _blurb.closeBtn?.addEventListener('click', hideBlurb);
        }

        function hideBlurb() {
          _initBlurbRefs();
          if (_blurb.el) _blurb.el.classList.add('hidden');
        }

        /**
         * Optional hook for your own text. If you set:
         *   window.composeBlurb = ({isWater, meteorName, sizeM, lat, lon}) => "HTML string";
         * it will be used. Otherwise we show a sensible default.
         */
        window.composeBlurb ||= null;

        function showImpactBlurb() {
          _initBlurbRefs();

          const isWater = !!lastImpactIsWater;
          const meteorName =
            (storedSelection?.name || storedSelection?.meteorProfileId || METEOR.asteroidId || 'Meteor');
          const sizeM = (storedSelection?.sizeMeters ?? ASTEROIDS[METEOR.asteroidId]?.sizeMeters) || null;

          const lat = METEOR.endLat;
          const lon = METEOR.endLon;

          // Title
          _blurb.title.textContent = sizeM
            ? `${meteorName} (${Number(sizeM).toFixed(0)} m)`
            : meteorName;

          // Body: either your custom composer or a default block
          let html = null;
          if (typeof window.composeBlurb === 'function') {
            try {
              const out = window.composeBlurb({ isWater, meteorName, sizeM, lat, lon });
              if (out === false) {
                // explicit "hide" from the composer
                _blurb.el.classList.add('hidden');
                return;
              }
              if (typeof out === 'string' && out.trim()) {
                html = out;
              }
            } catch (err) {
              console.warn('composeBlurb error:', err);
            }
          }
          if (!html) {
            html = `
              <div style="margin-bottom:.4rem;">
                Impact location: <strong>${lat.toFixed(2)}°, ${lon.toFixed(2)}°</strong>
              </div>
              <div style="margin-bottom:.6rem;">
                Classification: <strong>${isWater ? 'WATER' : 'LAND'}</strong>
                (your crosshair/rings will be ${isWater ? 'blue' : 'red'}).
              </div>
              <div style="opacity:.9;">
                Add your own notes here about consequences, mitigation steps, and next actions.
              </div>
            `;
          }
          _blurb.body.innerHTML = html;


          // Show + color edge
          _blurb.el.classList.remove('hidden', 'water', 'land');
          _blurb.el.classList.add(isWater ? 'water' : 'land');
        }
        // --------------------------------------------------------------------------


        // === water/land helper =====================================
        // remember the last pick's classification so we can color rings later
        let lastImpactIsWater = false;
        
        const WATER_CUTOFF_M = 1.0;

        // === Water/land via CDN masks (robust) ====================================
        const RES = "110m";        // "110m" fast; switch to "50m" for finer coasts later
        const OCEAN_ONLY = false;  // true => oceans only (lakes count as land)

        let landMask = null;       // FeatureCollection of Polygon/MultiPolygon
        let lakesMask = null;      // FeatureCollection (optional)
        let masksReady = null;

        // Always return a FeatureCollection (wrap single Feature if needed)
        function asFeatureCollection(geo) {
          if (!geo) return null;
          if (geo.type === "FeatureCollection") return geo;
          if (geo.type === "Feature") {
            return { type: "FeatureCollection", features: [geo] };
          }
          // bare geometry -> wrap in a Feature, then FC
          return { type: "FeatureCollection", features: [{ type: "Feature", properties: {}, geometry: geo }] };
        }

        function pointInAny(pt, featureCollection) {
          return Boolean(
            featureCollection &&
            Array.isArray(featureCollection.features) &&
            featureCollection.features.some(f => turf.booleanPointInPolygon(pt, f))
          );
        }

        function loadMasksFromCDN() {
          const landURL  = `https://unpkg.com/world-atlas@2.0.2/land-${RES}.json`;
          const lakesURL = `https://unpkg.com/world-atlas@2.0.2/lakes-${RES}.json`;

          return Promise.allSettled([
            fetch(landURL).then(r => r.json()),
            fetch(lakesURL).then(r => r.ok ? r.json() : null)
          ]).then(([landRes, lakesRes]) => {
            if (landRes.status === "fulfilled") {
              const topo = landRes.value;
              const landGeo = topojson.feature(topo, topo.objects.land);
              landMask = asFeatureCollection(landGeo);
            }
            if (lakesRes.status === "fulfilled" && lakesRes.value) {
              const topo = lakesRes.value;
              const lakesGeo = topojson.feature(topo, topo.objects.lakes);
              lakesMask = asFeatureCollection(lakesGeo);
            }
            console.log("[masks] land FC?", !!landMask, "lakes FC?", !!lakesMask, "res:", RES);
            if (!landMask || !landMask.features?.length) {
              throw new Error("Failed to load/normalize land mask");
            }
          });
        }
        masksReady = loadMasksFromCDN();

        // Return true if point is WATER at (lon, lat)
        function isWaterByMask(lon, lat) {
          const pt = turf.point([lon, lat]); // [lon, lat]
          const onLand = pointInAny(pt, landMask);
          if (!OCEAN_ONLY) return !onLand;   // oceans + lakes = water
          const inLake = pointInAny(pt, lakesMask); // false if lakesMask is null
          return !onLand && !inLake;         // oceans-only
        }
        // ==========================================================================


        // Helper to apply a camera setView using degrees-based config
        function applyCameraFromConfig(cfg) {
          if (!cfg) return;
          viewer.scene.camera.setView({
            destination: Cesium.Cartesian3.fromDegrees(
              cfg.destination.lon,
              cfg.destination.lat,
              cfg.destination.height
            ),
            orientation: cfg.orientation
          });
        }

        const launchButton = document.getElementById("launchMeteor");
        const returnButton = document.getElementById("returnToSelection");
        const timelineButton = document.getElementById("timeline");

timelineButton?.addEventListener('click', () => { window.location.href = '/timeline.html';  // change to your actual page path
});

        returnButton?.addEventListener('click', () => { window.location.href = '/'; });
        const angleSlider = document.getElementById("impactAngle");
        const angleVal    = document.getElementById("impactAngleVal");
        let impactAngleDeg = Number(angleSlider?.value || 30);
        angleSlider?.addEventListener("input", () => {
          impactAngleDeg = Number(angleSlider.value);
          angleVal.textContent = `${impactAngleDeg}°`;
        });
        const speedSlider = document.getElementById("speedMultiplier");
        const speedVal    = document.getElementById("speedMultiplierVal");
        let speedMult = Number(speedSlider?.value || 1.0);
        speedSlider?.addEventListener("input", () => {
          speedMult = Number(speedSlider.value);
          speedVal.textContent = `${(speedMult * 32000).toFixed(0)} mph`;
          viewer.clock.multiplier = speedMult;
        });

        let meteorActive = false;
        let impactCircleEntities = [];
        let impactCircleTimers = [];
        let epicenterSpheres = [];
        let activeTrail = null;
        let trajectoryEntity = null; // persistent path shown until next run
        let trajectoryPositions = []; // updated in real time to extend the trail
        let impactCrossEntity = null; // NEW crosshair marker
        let cityLabelEntity = null;
        let cityViewPayload = null;

        function clearEpicenterSpheres() {
          epicenterSpheres.forEach((e) => viewer.entities.remove(e));
          epicenterSpheres = [];
        }
        function createEpicenterSpheres() {
          clearEpicenterSpheres();
          const radii = [60, 120, 200, 300]; // very small concentric spheres (meters)
          const pos = Cesium.Cartesian3.fromDegrees(METEOR.endLon, METEOR.endLat, METEOR.endAlt);
          radii.forEach((r, i) => {
            const ent = viewer.entities.add({
              position: pos,
              ellipsoid: {
                radii: new Cesium.Cartesian3(r, r, r),
                material: Cesium.Color.ORANGE.withAlpha(0.22 + i * 0.12),
                outline: true,
                outlineColor: Cesium.Color.ORANGE.withAlpha(0.65 + i * 0.06),
                stackPartitions: 16,
                slicePartitions: 16,
              },
            });
            epicenterSpheres.push(ent);
          });
        }

        // NEW: create/update a crosshair billboard at the chosen point
        function updateImpactCross(color = 'rgba(255,80,80,1)') {
          if (impactCrossEntity) {
            viewer.entities.remove(impactCrossEntity);
            impactCrossEntity = null;
          }
          impactCrossEntity = viewer.entities.add({
            position: Cesium.Cartesian3.fromDegrees(METEOR.endLon, METEOR.endLat, 0.0),
            billboard: {
              image: makeCrossImage(44, color),
              verticalOrigin: Cesium.VerticalOrigin.CENTER,
              horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
              disableDepthTestDistance: Number.POSITIVE_INFINITY,
              scaleByDistance: new Cesium.NearFarScalar(500.0, 1.2, 5000000.0, 0.6)
            }
          });
        }

        // NEW: bake the flown trajectory into a static polyline that persists
        function bakeFinalTrajectory() {
          if (trajectoryEntity) {
            viewer.entities.remove(trajectoryEntity);
            trajectoryEntity = null;
          }
          if (trajectoryPositions.length >= 2) {
            trajectoryEntity = viewer.entities.add({
              polyline: {
                positions: trajectoryPositions.slice(),
                width: 6,
                material: new Cesium.PolylineGlowMaterialProperty({
                  color: Cesium.Color.ORANGE.withAlpha(0.9),
                  glowPower: 0.15
                })
              }
            });
          }
        }

        function clearCityLabel() {
          if (!cityLabelEntity) return;
          viewer.entities.remove(cityLabelEntity);
          cityLabelEntity = null;
        }

        function resetCityViewButton(reason = 'City view available after meteor landing near a major city.') {
          if (!cityViewBtn) return;
          cityViewPayload = null;
          cityViewBtn.disabled = true;
          cityViewBtn.classList.remove('btn-ready');
          cityViewBtn.title = reason;
        }

        function enableCityViewButton(payload, nearbyCity) {
          cityViewPayload = payload;
          if (!cityViewBtn) return;
          cityViewBtn.disabled = false;
          cityViewBtn.classList.add('btn-ready');
          cityViewBtn.title = `Inspect ${nearbyCity.name} (${payload.distanceKm} km from impact)`;
        }

        function highlightNearbyCity(city, distanceKm) {
          clearCityLabel();
          cityLabelEntity = viewer.entities.add({
            position: Cesium.Cartesian3.fromDegrees(city.lon, city.lat, 0.0),
            label: {
              text: `${city.name} (${distanceKm.toFixed(1)} km)`,
              font: '16px "Segoe UI", sans-serif',
              fillColor: Cesium.Color.WHITE,
              outlineColor: Cesium.Color.BLACK,
              outlineWidth: 2,
              style: Cesium.LabelStyle.FILL_AND_OUTLINE,
              verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
              pixelOffset: new Cesium.Cartesian2(0, -12),
              translucencyByDistance: new Cesium.NearFarScalar(500.0, 1.0, 2500000.0, 0.2),
              disableDepthTestDistance: Number.POSITIVE_INFINITY,
            },
          });
        }

        function findNearestMajorCity(lat, lon) {
          const impactCarto = Cesium.Cartographic.fromDegrees(lon, lat);
          let nearest = null;
          for (const city of MAJOR_CITIES) {
            const cityCarto = Cesium.Cartographic.fromDegrees(city.lon, city.lat);
            const geodesic = new Cesium.EllipsoidGeodesic(impactCarto, cityCarto);
            const distanceKm = (geodesic.surfaceDistance || 0) / 1000;
            if (!Number.isFinite(distanceKm)) continue;
            if (!nearest || distanceKm < nearest.distanceKm) {
              nearest = { city, distanceKm };
            }
          }
          return nearest;
        }

        function startMeteorRun() {
          if (!launchButton) { console.error("Simulate button is missing."); return; }
          if (meteorActive) return;

          resetCityViewButton();
          clearCityLabel();

          // Cleanup from prior runs (keep epicenter spheres & crosshair until new pick)
          impactCircleTimers.forEach((id) => window.clearTimeout(id));
          impactCircleTimers = [];
          impactCircleEntities.forEach((e) => viewer.entities.remove(e));
          impactCircleEntities = [];
          if (activeTrail) { viewer.scene.primitives.remove(activeTrail); activeTrail = null; }
          if (trajectoryEntity) { viewer.entities.remove(trajectoryEntity); trajectoryEntity = null; } // clear previous baked path ONLY when a new sim starts
          trajectoryPositions = [];

          launchButton.disabled = true;
          launchButton.classList.remove('btn-pulse');
          timelineButton.disabled = true;

          const asteroidProfile = ASTEROIDS[METEOR.asteroidId];
          const impactRadius = asteroidProfile
            ? Math.max(asteroidProfile.sizeMeters * 500.0, asteroidProfile.joules * JOULE_RADIUS_SCALE)
            : 50000.0;

          meteorActive = true;
          if (pickBtn) pickBtn.disabled = true;

          const startTime = Cesium.JulianDate.now();
          const stopTime = Cesium.JulianDate.addSeconds(startTime, METEOR.flightSeconds, new Cesium.JulianDate());

          viewer.clock.startTime = startTime.clone();
          viewer.clock.stopTime = stopTime.clone();
          viewer.clock.currentTime = startTime.clone();
          viewer.clock.clockRange = Cesium.ClockRange.CLAMPED;
          viewer.clock.multiplier = speedMult;
          viewer.clock.shouldAnimate = false;

          // === Build the curved path (trajectory) ==========================
          const tmpGeodesic = new Cesium.EllipsoidGeodesic(
            Cesium.Cartographic.fromDegrees(METEOR.startLon, METEOR.startLat),
            Cesium.Cartographic.fromDegrees(METEOR.endLon, METEOR.endLat)
          );
          const L = tmpGeodesic.surfaceDistance; // meters
          const angleRad = Cesium.Math.toRadians(Math.min(85, Math.max(0, impactAngleDeg)));

          // Choose start altitude so that dh/ds at end matches -tan(angle)
          const startAltForAngle = METEOR.endAlt + L * Math.tan(angleRad);

          const {
            samples: positionProperty,
            startCarto,
            endCarto,
          } = buildGeodesicPathSamples({
            startLon: METEOR.startLon, startLat: METEOR.startLat, startAlt: startAltForAngle,
            endLon: METEOR.endLon,     endLat: METEOR.endLat,     endAlt: METEOR.endAlt,
            flightSeconds: METEOR.flightSeconds,
            numPoints: 128,
            startTime,
            altExponent: 1 // linear to satisfy slope requirement at impact
          });

          const startCartesian = Cesium.Cartesian3.fromRadians(
            startCarto.longitude,
            startCarto.latitude,
            startAltForAngle
          );
          const endCartesian = Cesium.Cartesian3.fromRadians(
            endCarto.longitude,
            endCarto.latitude,
            METEOR.endAlt
          );

          const tailExtensionFactor = METEOR.tailExtensionFactor || 3.0;
          const tailVector = Cesium.Cartesian3.subtract(
            startCartesian,
            endCartesian,
            new Cesium.Cartesian3()
          );
          Cesium.Cartesian3.multiplyByScalar(tailVector, tailExtensionFactor, tailVector);
          const tailCartesian = Cesium.Cartesian3.add(
            startCartesian,
            tailVector,
            new Cesium.Cartesian3()
          );

          trajectoryPositions = [
            Cesium.Cartesian3.clone(startCartesian),
          ];

          const baseEntity = {
            position: positionProperty,
            orientation: new Cesium.VelocityOrientationProperty(positionProperty),
            path: {
              resolution: 1,
              leadTime: 0,
              trailTime: METEOR.trailSeconds,
              material: new Cesium.PolylineGlowMaterialProperty({ color: Cesium.Color.ORANGE, glowPower: 0.25 }),
              width: 8,
            },
          };

          const meteorEntity = viewer.entities.add(
            METEOR.useModel
              ? { ...baseEntity, model: { uri: METEOR.modelUri, minimumPixelSize: 32, scale: 1.0 } }
              : { ...baseEntity, point: { pixelSize: 12, color: Cesium.Color.YELLOW.withAlpha(0.95), outlineColor: Cesium.Color.ORANGE, outlineWidth: 2 } }
          );

          // Particle plume attached to meteor orientation
          const trailDuration = METEOR.flightSeconds + 20;
          const plume = new Cesium.ParticleSystem({
            image: makeParticleImage(32),
            startScale: 1.0, endScale: 0.5, emissionRate: 140,
            particleLife: trailDuration, lifetime: trailDuration, speed: 800.0,
            emitter: new Cesium.ConeEmitter(Cesium.Math.toRadians(10)), sizeInMeters: true,
          });
          viewer.scene.primitives.add(plume);
          activeTrail = plume;

          let burstTimeoutId = null;
          let burstPrimitive = null;
          let preRenderCallback;

          const finalize = () => {
            if (burstTimeoutId !== null) { window.clearTimeout(burstTimeoutId); burstTimeoutId = null; }
            viewer.scene.preRender.removeEventListener(preRenderCallback);
            if (burstPrimitive) { viewer.scene.primitives.remove(burstPrimitive); burstPrimitive = null; }
            viewer.entities.remove(meteorEntity);
            viewer.clock.shouldAnimate = false;
            meteorActive = false;
            if (pickBtn) pickBtn.disabled = false;
            launchButton.disabled = false;
            launchButton.classList.add('btn-pulse');
            timelineButton.disabled = false;
            // Ensure spheres are present at the epicenter
            createEpicenterSpheres();
            const nearestCity = findNearestMajorCity(METEOR.endLat, METEOR.endLon);
            if (nearestCity && nearestCity.distanceKm <= CITY_PROXIMITY_THRESHOLD_KM) {
              highlightNearbyCity(nearestCity.city, nearestCity.distanceKm);
              enableCityViewButton({
                city: nearestCity.city.name,
                cityLat: nearestCity.city.lat.toFixed(4),
                cityLon: nearestCity.city.lon.toFixed(4),
                impactLat: METEOR.endLat.toFixed(4),
                impactLon: METEOR.endLon.toFixed(4),
                distanceKm: nearestCity.distanceKm.toFixed(1),
              }, nearestCity.city);
            } else {
              clearCityLabel();
              resetCityViewButton(`No major city within ${CITY_PROXIMITY_THRESHOLD_KM} km of impact.`);
            }
          };

          const rotationScratch = new Cesium.Matrix3();
          const flipMatrix = Cesium.Matrix3.fromRotationY(Math.PI, new Cesium.Matrix3());
          const plumeMatrix = new Cesium.Matrix4();

          preRenderCallback = function (_scene, time) {
            const now = time || viewer.clock.currentTime;
            const position = baseEntity.position.getValue(now);
            if (!position) return;

            const orientation = meteorEntity.orientation.getValue(now);
            if (orientation) {
              Cesium.Matrix3.fromQuaternion(orientation, rotationScratch);
              Cesium.Matrix3.multiply(rotationScratch, flipMatrix, rotationScratch);
              Cesium.Matrix4.fromRotationTranslation(rotationScratch, position, plumeMatrix);
              plume.modelMatrix = plumeMatrix;
            } else {
              Cesium.Transforms.eastNorthUpToFixedFrame(position, undefined, plumeMatrix);
              plume.modelMatrix = plumeMatrix;
            }

            const lastRecorded = trajectoryPositions[trajectoryPositions.length - 1];
            const minDistance = METEOR.tailAddMinDistance || 5000;
            const shouldAdd = !lastRecorded || Cesium.Cartesian3.distance(position, lastRecorded) > minDistance;
            if (shouldAdd) {
              trajectoryPositions.push(Cesium.Cartesian3.clone(position));
              const maxPoints = METEOR.tailMaxPoints || 600;
              if (trajectoryPositions.length > maxPoints) {
                const excess = trajectoryPositions.length - maxPoints;
                trajectoryPositions.splice(1, excess); // preserve tail anchor at index 0
              }
            }

            const cartographic = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);
            const lowAltitude = cartographic ? cartographic.height < 1500.0 : false;
            const reachedEnd = Cesium.JulianDate.greaterThanOrEquals(now, stopTime);

            if (reachedEnd || lowAltitude) {
              viewer.scene.preRender.removeEventListener(preRenderCallback);

              meteorEntity.show = false;
              viewer.clock.currentTime = stopTime.clone();

              const finalRecorded = trajectoryPositions[trajectoryPositions.length - 1];
              if (!finalRecorded || !Cesium.Cartesian3.equalsEpsilon(endCartesian, finalRecorded, Cesium.Math.EPSILON3)) {
                trajectoryPositions.push(Cesium.Cartesian3.clone(endCartesian));
              }

              // NEW: bake the full flown path into a persistent polyline
              bakeFinalTrajectory();

              const impactCartesian = Cesium.Cartesian3.fromDegrees(METEOR.endLon, METEOR.endLat, 10.0);
              burstPrimitive = new Cesium.ParticleSystem({
                image: makeParticleImage(48), startScale: 2.0, endScale: 6.0,
                emissionRate: 0, lifetime: 1.6, particleLife: 0.8, speed: 120.0, sizeInMeters: true,
                emitter: new Cesium.SphereEmitter(80.0),
                modelMatrix: Cesium.Transforms.eastNorthUpToFixedFrame(impactCartesian),
                bursts: [ new Cesium.ParticleBurst({ time: 0.0, minimum: 300, maximum: 300 }) ],
              });
              viewer.scene.primitives.add(burstPrimitive);

              // Expanding 2D shock rings (keep existing visual)
              if (impactCircleEntities.length === 0) {
                const circleCount = 5, delayMs = 1000;
                const radiusStep = impactRadius / circleCount;
                const baseColor = lastImpactIsWater ? Cesium.Color.BLUE : Cesium.Color.RED;
                for (let i = 0; i < circleCount; i++) {
                  const timerId = window.setTimeout(() => {
                    const radius = radiusStep * (i + 1);
                    const circle = viewer.entities.add({
                      position: Cesium.Cartesian3.fromDegrees(METEOR.endLon, METEOR.endLat, METEOR.endAlt),
                      ellipse: {
                        semiMajorAxis: radius, semiMinorAxis: radius, height: METEOR.endAlt,
                        material: baseColor.withAlpha(0.25 + i * 0.12),
                        outline: true, outlineColor: baseColor.withAlpha(0.6 + i * 0.08), outlineWidth: 3,
                      },
                    });
                    impactCircleEntities.push(circle);
                  }, i * delayMs);
                  impactCircleTimers.push(timerId);
                }
              }

              burstTimeoutId = window.setTimeout(finalize, 2000);
            }
          };

          viewer.scene.preRender.addEventListener(preRenderCallback);
          viewer.clock.shouldAnimate = true; // Go!
        }

        // === Impact picking (click anywhere to set endLon/Lat) ===
        const pickBtn = document.getElementById("pickImpact");
        const cityViewBtn = document.getElementById("cityView");
        const impactDisp = document.getElementById("impactDisplay");
        const centerBlurb = document.getElementById("centerBlurb");

        function updateImpactDisplay() {
          if (impactDisp) impactDisp.textContent = `${METEOR.endLat.toFixed(4)}°, ${METEOR.endLon.toFixed(4)}°`;
        }
        updateImpactDisplay();
        resetCityViewButton();

        // Start in picking mode immediately
        let pickingImpact = true;
        pickBtn && (pickBtn.textContent = "Clear selection");
        viewer.canvas.style.cursor = "crosshair";

        const clickHandler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
        pickBtn?.addEventListener("click", () => {
          pickingImpact = !pickingImpact;
          pickBtn.textContent = pickingImpact ? "Click on globe…" : "Pick Impact";
          viewer.canvas.style.cursor = pickingImpact ? "crosshair" : "";
          if (pickingImpact) {
            if (centerBlurb) centerBlurb.style.display = 'block';
            resetCityViewButton();
            clearCityLabel();
          }
        });

        // === Impact picking (click anywhere to set endLon/Lat) ===
        clickHandler.setInputAction(async (evt) => {
          if (!pickingImpact) return;

          console.log("[pick] clicked", evt.position); // debug

          const scene = viewer.scene;

          // Try 1: 3D scene depth-based pick (when available)
          let cartesian = scene.pickPosition?.(evt.position);

          // Try 2: Ray/globe intersection
          if (!cartesian) {
            const ray = scene.camera.getPickRay(evt.position);
            cartesian = scene.globe.pick(ray, scene);
          }

          // Try 3: Ellipsoid fallback (always works if you click on the globe)
          if (!cartesian) {
            cartesian = scene.camera.pickEllipsoid(evt.position, Cesium.Ellipsoid.WGS84);
          }

          if (!cartesian) {
            console.warn("[pick] no cartesian found (clicked UI or outside globe?)");
            return;
          }

          const carto = Cesium.Cartographic.fromCartesian(cartesian);
          const lon = Cesium.Math.toDegrees(carto.longitude);
          const lat = Cesium.Math.toDegrees(carto.latitude);
          METEOR.endLon = lon;
          METEOR.endLat = lat;
          updateImpactDisplay();

          // Water/land classification
          await masksReady;
          lastImpactIsWater = isWaterByMask(lon, lat);
          const crossColor = lastImpactIsWater ? 'rgba(64,160,255,1)' : 'rgba(255,80,80,1)';

          createEpicenterSpheres();
          updateImpactCross(crossColor);
          clearCityLabel();
          resetCityViewButton();

          if (centerBlurb) setTimeout(() => (centerBlurb.style.display = 'none'), 600);
          if (launchButton) { launchButton.disabled = false; launchButton.classList.add('btn-pulse'); }
          showImpactBlurb();

          pickingImpact = false;
          pickBtn && (pickBtn.textContent = "Pick Impact");
          viewer.canvas.style.cursor = "";
        }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

        // === End impact picking ===

        if (launchButton) launchButton.addEventListener("click", startMeteorRun);
        cityViewBtn?.addEventListener("click", () => {
          if (!cityViewPayload) return;
          const destination = new URL('./city-view-placeholder.html', window.location.href);
          for (const [key, value] of Object.entries(cityViewPayload)) {
            destination.searchParams.set(key, value);
          }
          window.location.href = destination.toString();
        });

        // ---- Your per-meteor copy (keys are "a1","a2","a3","a4") -----------------
        // ---- Per-meteor text registry --------------------------------------------
        // Write ALL your text here. One object per meteorProfileId.
        // Provide either {land, water} or a single {any}.
        // Placeholders: {name}, {size}, {lat}, {lon}
        // Map real meteor ids to your a1/a2/a3/a4 buckets
        const ID_ALIAS = {
          "2010 ER12": "a1",
          "2014 HN197": "a2",
          "2023 TB2":  "a3",
          "2022 VF1":  "a4",
          "2000 WJ107": "a4",
          "2025 RM1":   "a4",
          "2024 RS16":  "a4",
          // already-normalized ok:
          a1:"a1", a2:"a2", a3:"a3", a4:"a4",
        };

        // ---- Per-meteor text registry --------------------------------------------
        const BLURB_BY_METEOR = {
          "2010 ER12": {
            land: `
              <h3>LAND</h3>
              <p><strong>{name}</strong> ({size} m) at <strong>{lat}°, {lon}°</strong></p>
              <ul>
                <li>Although some of the asteroid’s material will be burned away as it falls through 
                Earth’s atmosphere, its impact will be unbelievably catastrophic. It will release energy 
                equivalent to 120,000 megatons of TNT, or 8 million Hiroshima nuclear bombs, and will release 
                seismic waves equivalent to an 8-9 magnitude earthquake—felt up to thousands of kilometers away. 
                It will devastate entire countries, and cause environmental and climate effects across the globe.</li>
                <li>Although you can try to warn people ahead of time, evacuating multiple countries is not easy. 
                You are screwed.</li>
              </ul>
            `,
            water: `
              <h3>OCEAN</h3>
              <p><strong>{name}</strong> ({size} m) at <strong>{lat}°, {lon}°</strong></p>
              <ul>
                <li>Although some of the asteroid’s material will be burned away as it falls through Earth’s atmosphere, 
                  its impact will be unbelievably catastrophic, releasing energy equivalent to 120,000 megatons of TNT, or 
                  8 million Hiroshima nuclear bombs. It lands in water, which will reduce the seismic effects significantly, 
                  but this will not save you. The impact and huge crater will cause mega-tsunamis to continuously ripple 
                  in all directions, hitting coastlines over 1000 km away. Water will vaporize, dropping local temperatures 
                  and causing a global greenhouse gas effect. Human society as we know it will likely collapse.</li>
                <li>You are screwed. </li>
              </ul>
            `,
          },
          "2014 HN197": {
            land: `
              <h3>LAND</h3>
              <p><strong>{name}</strong> ({size} m) at <strong>{lat}°, {lon}°</strong></p>
              <ul>
                <li>Although some of the asteroid’s material will be burned away as it falls through 
                  Earth’s atmosphere, its impact will be big. It will release energy equivalent to 3300 
                  megatons of TNT, or 287,000 Hiroshima nuclear bombs, and will release seismic waves 
                  equivalent to a 7-8 magnitude earthquake. It will cause continent-wide damage, and the 
                  resulting fires and temperature fluctuations will be devastating. </li>
                <li>Although you can try to warn people ahead of time, evacuating an entire country is 
                  not easy. You are screwed. </li>
              </ul>
            `,
            water: `
              <h3>OCEAN</h3>
              <p><strong>{name}</strong> ({size} m) at <strong>{lat}°, {lon}°</strong></p>
              <ul>
                <li>Although some of the asteroid’s material will be burned away as it falls through Earth’s 
                  atmosphere, its impact will be big, releasing energy equivalent to 3300 megatons of TNT, 
                  or 287,000 Hiroshima nuclear bombs. It lands in water, which will reduce the seismic 
                  effects significantly, but tsunamis will still devastate coastlines for hundreds of 
                  kilometers. It would likely cause a greenhouse gas effect in the environment, and regional 
                  ocean life will be destroyed. However, it will not cause a global extinction, and despite 
                  lingering threats to resources, your society will likely survive.</li>
                <li>If you are on a coastline with no tsunami precautions, evacuation will likely take too 
                  long, and you are screwed. If you have early warning systems and high sea walls, you will 
                  probably survive! Congratulations!</li>
              </ul>
            `,
          },
          "2023 TB2": {
            land: `
              <h3>LAND</h3>
              <p><strong>{name}</strong> ({size} m) at <strong>{lat}°, {lon}°</strong></p>
              <ul>
                <li>Although most of the asteroid’s material will be burned away as it falls through 
                  Earth’s atmosphere, its impact will be big, releasing energy equivalent to 5.3 
                  megatons of TNT, or 353 Hiroshima nuclear bombs. Meteors this size have a good chance 
                  of breaking apart before they reach the ground, but even if it explodes in the air, 
                  an immense shockwave will flatten trees for kilometers. If it does hit the ground, 
                  it will cause seismic waves equivalent to a 5-6 magnitude earthquake. There will be 
                  widespread local destruction and injury.</li>
                <li>If the impact happens in a dense urban area, property damage will be immense. 
                  However, with proper infrastructure (public transit, emergency shelters, rapid 
                  information dissemination), casualties can be minimized. Congratulations!</li>
              </ul>
            `,
            water: `
              <h3>OCEAN</h3>
              <p><strong>{name}</strong> ({size} m) at <strong>{lat}°, {lon}°</strong></p>
              <ul>
                <li>Although most of the asteroid’s material will be burned away as it falls through 
                  Earth’s atmosphere, its impact will be big, releasing energy equivalent to 5.3 megatons 
                  of TNT, or 353 Hiroshima nuclear bombs. Meteors this size have a good chance of 
                  breaking apart before they reach the ground, but even if it explodes in the air, an 
                  immense shockwave will radiate for kilometers. However, it lands in water, which will 
                  reduce the seismic effects significantly. At this size, there is a low risk of ocean-wide 
                  tsunamis, but if it hits next to land, the waves generated will likely cause damage to 
                  the coastline. </li>
                <li>If you are on a very nearby coastline, you need tsunami precautions (early warning 
                  system, sea walls, high ground) to minimize damage. However, most coastlines won’t 
                  even be impacted. Congratulations! </li>
              </ul>
            `,
          },
          "2022 VF1": {
            land: `
              <h3>LAND</h3>
              <p><strong>{name}</strong> ({size} m) at <strong>{lat}°, {lon}°</strong></p>
              <ul>
                <li>Although some of the asteroid’s material will be burned away as it falls through 
                  Earth’s atmosphere, its impact will be big. It will release energy equivalent to 120 
                  megatons of TNT, or 8000 Hiroshima nuclear bombs, and will cause seismic waves equivalent 
                  to a 6-7 magnitude earthquake. The shockwave will cause immense regional destruction for 
                  many kilometers.</li>
                <li>If the impact happens in a dense urban area, property damage will be immense, and 
                  mass casualties are likely. It will be very difficult to evacuate an area larger than 
                  New York City, but with proper infrastructure (public transit, emergency shelters, 
                  rapid information dissemination), you have a chance of minimizing casualties. 
                  Congratulations!</li>
              </ul>
            `,
            water: `
              <h3>OCEAN</h3>
              <p><strong>{name}</strong> ({size} m) at <strong>{lat}°, {lon}°</strong></p>
              <ul>
                <li>Although some of the asteroid’s material will be burned away as it falls through 
                  Earth’s atmosphere, its impact will be big, releasing energy equivalent to 120 megatons 
                  of TNT, or 8000 Hiroshima nuclear bombs. However, it lands in water, which will reduce 
                  the seismic effects significantly. At this size, there is a low risk of truly devastating 
                  ocean-wide tsunamis, but if it hits next to land, the waves generated will cause huge 
                  damage to the coastline. Local ocean life will also be devastated.</li>
                <li>If you are on a nearby coastline, you will need tsunami precautions (early warning 
                  system, sea walls, high ground) to minimize damage. Even with maximum precautions, this 
                  may not be enough to mitigate the huge waves generated by the meteor. However, most 
                  coastlines won’t even be impacted. Congratulations! </li>
              </ul>
            `,
          },
          "2000 WJ107": {
            land: `
              <h3>LAND</h3>
              <p><strong>{name}</strong> ({size} m) at <strong>{lat}°, {lon}°</strong></p>
              <ul>
                <li>Although most of the asteroid’s material will be burned away as it falls through 
                  Earth’s atmosphere, its impact will be big, releasing energy equivalent to 24 megatons 
                  of TNT, or 1600 Hiroshima nuclear bombs. Meteors this size have a good chance of breaking 
                  apart before they reach the ground, but even if it explodes in the air, an immense 
                  shockwave will flatten trees for kilometers. If it does hit the ground, it will cause 
                  seismic waves equivalent to a 5-6 magnitude earthquake. There will be widespread local 
                  destruction and injury. </li>
                <li>If the impact happens in a dense urban area, property damage will be immense. However, 
                  with proper infrastructure (public transit, emergency shelters, rapid information 
                  dissemination), casualties can be minimized. Congratulations!</li>
              </ul>
            `,
            water: `
              <h3>OCEAN</h3>
              <p><strong>{name}</strong> ({size} m) at <strong>{lat}°, {lon}°</strong></p>
              <ul>
                <li>Although most of the asteroid’s material will be burned away as it falls through 
                  Earth’s atmosphere, its impact will be big, releasing energy equivalent to 24 megatons 
                  of TNT, or 1600 Hiroshima nuclear bombs. Meteors this size have a good chance of breaking 
                  apart before they reach the ground, but even if it explodes in the air, an immense 
                  shockwave will radiate for kilometers. However, it lands in water, which will reduce the 
                  seismic effects significantly. At this size, there is a low risk of ocean-wide tsunamis, 
                  but if it hits next to land, the waves generated will likely cause damage to the coastline. </li>
                <li>If you are on a very nearby coastline, you need tsunami precautions (early warning 
                  system, sea walls, high ground) to minimize damage. However, most coastlines won’t even 
                  be impacted. Congratulations! </li>
              </ul>
            `,
          },
          "2025 RM1": {
            land: `
              <h3>LAND</h3>
              <p><strong>{name}</strong> ({size} m) at <strong>{lat}°, {lon}°</strong></p>
              <ul>
                <li>Although most of the asteroid’s material will be burned away as it falls through 
                  Earth’s atmosphere, its impact will be big, releasing energy equivalent to 5.3 megatons 
                  of TNT, or 353 Hiroshima nuclear bombs. Meteors this size have a good chance of breaking 
                  apart before they reach the ground, but even if it explodes in the air, an immense 
                  shockwave will flatten trees for kilometers. If it does hit the ground, it will cause 
                  seismic waves equivalent to a 5-6 magnitude earthquake. There will be widespread local 
                  destruction and injury.</li>
                <li>If the impact happens in a dense urban area, property damage will be immense. 
                  However, with proper infrastructure (public transit, emergency shelters, rapid 
                  information dissemination), casualties can be minimized. Congratulations!</li>
              </ul>
            `,
            water: `
              <h3>OCEAN</h3>
              <p><strong>{name}</strong> ({size} m) at <strong>{lat}°, {lon}°</strong></p>
              <ul>
                <li>Although most of the asteroid’s material will be burned away as it falls through 
                  Earth’s atmosphere, its impact will be big, releasing energy equivalent to 5.3 megatons 
                  of TNT, or 353 Hiroshima nuclear bombs. Meteors this size have a good chance of breaking 
                  apart before they reach the ground, but even if it explodes in the air, an immense 
                  shockwave will flatten trees for kilometers. If it does hit the ground, it will cause 
                  seismic waves equivalent to a 5-6 magnitude earthquake. There will be widespread local 
                  destruction and injury.</li>
                <li>If the impact happens in a dense urban area, property damage will be immense. 
                  However, with proper infrastructure (public transit, emergency shelters, rapid 
                  information dissemination), casualties can be minimized. Congratulations!</li>
              </ul>
            `,
          },
          "2024 RS16": {
            land: `
              <h3>LAND</h3>
              <p><strong>{name}</strong> ({size} m) at <strong>{lat}°, {lon}°</strong></p>
              <ul>
                <li>Your object is 0.005 kilometers in diameter. According to NASA, tens of millions of 
                  Near Earth Objects (NEOs) exist with a size less than 50 meters. We have found less than 
                  1% of these objects. At this size, your asteroid is very likely to break up as it falls 
                  through Earth’s atmosphere, causing no significant damage on the ground. No mitigation needed! </li>
              </ul>
            `,
            water: `
              <h3>OCEAN</h3>
              <p><strong>{name}</strong> ({size} m) at <strong>{lat}°, {lon}°</strong></p>
              <li>Your object is 0.005 kilometers in diameter. According to NASA, tens of millions of 
                  Near Earth Objects (NEOs) exist with a size less than 50 meters. We have found less than 
                  1% of these objects. At this size, your asteroid is very likely to break up as it falls 
                  through Earth’s atmosphere, causing no significant damage on the ground. No mitigation needed! </li>
            `,
          }
        };

        // Final composer — returns EXACTLY ONE block (else null -> fallback)
        window.composeBlurb = function ({ isWater, meteorName, sizeM, lat, lon }) {
          const rawId = (METEOR.asteroidId);
          // const id = ID_ALIAS[rawId] || rawId;             // normalize to a1/a2/a3/a4
          console.log("compose id:", rawId, "→", rawId, "entry?", !!BLURB_BY_METEOR[rawId]);

          const entry = BLURB_BY_METEOR[rawId];
          if (!entry) return null;

          const template = (isWater ? entry.water : entry.land) ?? entry.any;
          if (!template) return null;

          const sizeTxt = (sizeM != null && isFinite(sizeM)) ? String(Number(sizeM).toFixed(0)) : "—";
          return template
            .replaceAll("{name}", meteorName)
            .replaceAll("{size}", sizeTxt)
            .replaceAll("{lat}", lat.toFixed(2))
            .replaceAll("{lon}", lon.toFixed(2));
        };

      })();

    </script>
  </body>
</html>
