<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Globe Simulator</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      rel="stylesheet"
      href="./node_modules/cesium/Build/Cesium/Widgets/widgets.css"
    />
    <style>
      :root {
        color-scheme: dark;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      }

      body {
        margin: 0;
        background: #0b1a2a;
        color: #f1f3f5;
        overflow: hidden;
      }

      #cesiumContainer {
        position: absolute;
        inset: 0;
      }

      .overlay {
        position: absolute;
        top: 1.5rem;
        left: 1.5rem;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        z-index: 10;
        background: rgba(6, 17, 32, 0.8);
        border: 1px solid rgba(110, 191, 244, 0.35);
        border-radius: 0.75rem;
        padding: 1rem 1.25rem;
        max-width: 20rem;
        backdrop-filter: blur(6px);
        box-shadow: 0 12px 35px rgba(0, 0, 0, 0.35);
      }

      .overlay h1 {
        margin: 0;
        font-size: 1.25rem;
      }

      .overlay p {
        margin: 0;
        font-size: 0.95rem;
        line-height: 1.45;
        color: #c8d6e5;
      }

      .overlay button {
        margin-top: 0.75rem;
        padding: 0.5rem 1.1rem;
        font-size: 0.85rem;
        border: 1px solid rgba(125, 211, 252, 0.45);
        border-radius: 999px;
        background: linear-gradient(120deg, #1d8cf8, #935ade);
        color: #ffffff;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        box-shadow: 0 8px 22px rgba(33, 150, 243, 0.35);
      }

      .overlay button:hover:enabled {
        transform: translateY(-1px);
        box-shadow: 0 12px 28px rgba(33, 150, 243, 0.4);
      }

      .overlay button:disabled {
        opacity: 0.6;
        cursor: default;
        box-shadow: none;
      }

      .credits {
        position: absolute;
        bottom: 1rem;
        right: 1rem;
        font-size: 0.8rem;
        color: rgba(220, 230, 244, 0.7);
        background: rgba(15, 23, 42, 0.65);
        padding: 0.4rem 0.75rem;
        border-radius: 999px;
        border: 1px solid rgba(100, 116, 139, 0.4);
        backdrop-filter: blur(4px);
      }
    </style>
  </head>
  <body>
    <div class="overlay">
      <h1>Globe Simulator</h1>
      <p>
        Explore Cesiumâ€™s analytic geometries plus a scripted meteor entry with
        glowing trails and an impact burst. Click Launch Meteor to run the
        sequence, then use mouse or trackpad gestures to orbit, zoom, and
        inspect each feature.
      </p>
      <button id="launchMeteor" type="button">Launch Meteor</button>
    </div>
    <div id="cesiumContainer"></div>
    <div class="credits">Powered by CesiumJS + OpenStreetMap imagery</div>

    <script>
      window.CESIUM_BASE_URL = "./node_modules/cesium/Build/Cesium/";
      window.CESIUM_ION_TOKEN = "__CESIUM_ION_TOKEN__";
    </script>
    <script src="./node_modules/cesium/Build/Cesium/Cesium.js"></script>
    <script>
      (function () {
        if (!window.Cesium) {
          console.error("Cesium failed to load. Check the script path.");
          return;
        }

        Cesium.buildModuleUrl.setBaseUrl(window.CESIUM_BASE_URL);

        // Prefer Ion resources when a token is available; otherwise fall back to OSM.
        const ionToken =
          typeof window.CESIUM_ION_TOKEN === "string" &&
          window.CESIUM_ION_TOKEN.trim() !== "" &&
          window.CESIUM_ION_TOKEN !== "__CESIUM_ION_TOKEN__"
            ? window.CESIUM_ION_TOKEN
            : null;

        if (ionToken) {
          Cesium.Ion.defaultAccessToken = ionToken;
        } else {
          console.warn(
            "CESIUM_ION_TOKEN not provided. Falling back to public imagery providers only."
          );
        }

        const viewerOptions = {
          infoBox: false,
        };

        if (!ionToken) {
          viewerOptions.imageryProvider = new Cesium.OpenStreetMapImageryProvider({
            url: "https://tile.openstreetmap.org/",
          });
          viewerOptions.terrainProvider = new Cesium.EllipsoidTerrainProvider();
        }

        Cesium.Math.setRandomNumberSeed(1234);

        const viewer = new Cesium.Viewer("cesiumContainer", viewerOptions);
        const entities = viewer.entities;

        let i;
        let height;
        let positions;

        const stripeMaterial = new Cesium.StripeMaterialProperty({
          evenColor: Cesium.Color.WHITE.withAlpha(0.5),
          oddColor: Cesium.Color.BLUE.withAlpha(0.5),
          repeat: 5.0,
        });

        entities.add({
          rectangle: {
            coordinates: Cesium.Rectangle.fromDegrees(-92.0, 20.0, -86.0, 27.0),
            outline: true,
            outlineColor: Cesium.Color.WHITE,
            outlineWidth: 4,
            stRotation: Cesium.Math.toRadians(45),
            material: stripeMaterial,
          },
        });

        entities.add({
          polygon: {
            hierarchy: new Cesium.PolygonHierarchy(
              Cesium.Cartesian3.fromDegreesArray([
                -107.0, 27.0, -107.0, 22.0, -102.0, 23.0, -97.0, 21.0, -97.0, 25.0,
              ]),
            ),
            outline: true,
            outlineColor: Cesium.Color.WHITE,
            outlineWidth: 4,
            material: stripeMaterial,
          },
        });

        entities.add({
          position: Cesium.Cartesian3.fromDegrees(-80.0, 25.0),
          ellipse: {
            semiMinorAxis: 300000.0,
            semiMajorAxis: 500000.0,
            rotation: Cesium.Math.toRadians(-40.0),
            outline: true,
            outlineColor: Cesium.Color.WHITE,
            outlineWidth: 4,
            stRotation: Cesium.Math.toRadians(22),
            material: stripeMaterial,
          },
        });

        entities.add({
          position: Cesium.Cartesian3.fromDegrees(-72.0, 25.0),
          ellipse: {
            semiMinorAxis: 250000.0,
            semiMajorAxis: 250000.0,
            rotation: Cesium.Math.toRadians(-40.0),
            outline: true,
            outlineColor: Cesium.Color.WHITE,
            outlineWidth: 4,
            stRotation: Cesium.Math.toRadians(90),
            material: stripeMaterial,
          },
        });

        entities.add({
          rectangle: {
            coordinates: Cesium.Rectangle.fromDegrees(-118.0, 38.0, -116.0, 40.0),
            extrudedHeight: 500000.0,
            outline: true,
            outlineColor: Cesium.Color.WHITE,
            outlineWidth: 4,
            stRotation: Cesium.Math.toRadians(45),
            material: Cesium.Color.fromRandom({ alpha: 1.0 }),
          },
        });

        entities.add({
          position: Cesium.Cartesian3.fromDegrees(-117.0, 35.0),
          ellipse: {
            semiMinorAxis: 100000.0,
            semiMajorAxis: 200000.0,
            height: 100000.0,
            extrudedHeight: 200000.0,
            rotation: Cesium.Math.toRadians(90.0),
            outline: true,
            outlineColor: Cesium.Color.WHITE,
            outlineWidth: 4,
            material: Cesium.Color.fromRandom({ alpha: 1.0 }),
          },
        });

        entities.add({
          polygon: {
            hierarchy: new Cesium.PolygonHierarchy(
              Cesium.Cartesian3.fromDegreesArray([
                -118.0, 30.0, -115.0, 30.0, -117.1, 31.1, -118.0, 33.0,
              ]),
            ),
            height: 300000.0,
            extrudedHeight: 700000.0,
            outline: true,
            outlineColor: Cesium.Color.WHITE,
            outlineWidth: 4,
            material: Cesium.Color.fromRandom({ alpha: 1.0 }),
          },
        });

        entities.add({
          position: Cesium.Cartesian3.fromDegrees(-70.0, 45.0, 100000.0),
          cylinder: {
            hierarchy: new Cesium.PolygonHierarchy(
              Cesium.Cartesian3.fromDegreesArray([
                -118.0, 30.0, -115.0, 30.0, -117.1, 31.1, -118.0, 33.0,
              ]),
            ),
            length: 200000.0,
            topRadius: 150000.0,
            bottomRadius: 150000.0,
            outline: true,
            outlineColor: Cesium.Color.WHITE,
            outlineWidth: 4,
            material: Cesium.Color.fromRandom({ alpha: 1.0 }),
          },
        });

        for (i = 0; i < 5; ++i) {
          height = 100000.0 + 200000.0 * i;
          entities.add({
            position: Cesium.Cartesian3.fromDegrees(-106.0, 45.0, height),
            box: {
              dimensions: new Cesium.Cartesian3(90000.0, 90000.0, 90000.0),
              outline: true,
              outlineColor: Cesium.Color.WHITE,
              outlineWidth: 2,
              material: Cesium.Color.fromRandom({ alpha: 0.5 }),
            },
          });

          entities.add({
            position: Cesium.Cartesian3.fromDegrees(-102.0, 45.0, height),
            ellipsoid: {
              radii: new Cesium.Cartesian3(45000.0, 45000.0, 90000.0),
              outline: true,
              outlineColor: Cesium.Color.WHITE,
              outlineWidth: 2,
              material: Cesium.Color.fromRandom({ alpha: 0.5 }),
            },
          });

          entities.add({
            position: Cesium.Cartesian3.fromDegrees(-98.0, 45.0, height),
            ellipsoid: {
              radii: new Cesium.Cartesian3(67500.0, 67500.0, 67500.0),
              outline: true,
              outlineColor: Cesium.Color.WHITE,
              outlineWidth: 2,
              material: Cesium.Color.fromRandom({ alpha: 0.5 }),
            },
          });
        }

        entities.add({
          wall: {
            positions: Cesium.Cartesian3.fromDegreesArray([
              -95.0, 50.0, -85.0, 50.0, -75.0, 50.0,
            ]),
            maximumHeights: [500000, 1000000, 500000],
            minimumHeights: [0, 500000, 0],
            outline: true,
            outlineColor: Cesium.Color.LIGHTGRAY,
            outlineWidth: 4,
            material: Cesium.Color.fromRandom({ alpha: 0.7 }),
          },
        });

        entities.add({
          rectangle: {
            coordinates: Cesium.Rectangle.fromDegrees(-92.0, 30.0, -85.0, 40.0),
            material: stripeMaterial,
          },
        });

        entities.add({
          polygon: {
            hierarchy: {
              positions: Cesium.Cartesian3.fromDegreesArray([
                -109.0, 30.0, -95.0, 30.0, -95.0, 40.0, -109.0, 40.0,
              ]),
              holes: [
                {
                  positions: Cesium.Cartesian3.fromDegreesArray([
                    -107.0, 31.0, -107.0, 39.0, -97.0, 39.0, -97.0, 31.0,
                  ]),
                  holes: [
                    {
                      positions: Cesium.Cartesian3.fromDegreesArray([
                        -105.0, 33.0, -99.0, 33.0, -99.0, 37.0, -105.0, 37.0,
                      ]),
                      holes: [
                        {
                          positions: Cesium.Cartesian3.fromDegreesArray([
                            -103.0, 34.0, -101.0, 34.0, -101.0, 36.0, -103.0, 36.0,
                          ]),
                        },
                      ],
                    },
                  ],
                },
              ],
            },
            material: stripeMaterial,
          },
        });

        entities.add({
          position: Cesium.Cartesian3.fromDegrees(-80.0, 35.0),
          ellipse: {
            semiMinorAxis: 200000.0,
            semiMajorAxis: 500000.0,
            rotation: Cesium.Math.toRadians(30.0),
            material: stripeMaterial,
          },
        });

        entities.add({
          position: Cesium.Cartesian3.fromDegrees(-72.0, 35.0),
          ellipse: {
            semiMinorAxis: 200000.0,
            semiMajorAxis: 200000.0,
            rotation: Cesium.Math.toRadians(30.0),
            material: stripeMaterial,
          },
        });

        entities.add({
          rectangle: {
            coordinates: Cesium.Rectangle.fromDegrees(-110.0, 38.0, -107.0, 40.0),
            height: 700000.0,
            extrudedHeight: 1000000.0,
            rotation: Cesium.Math.toRadians(45),
            material: Cesium.Color.fromRandom({ alpha: 1.0 }),
          },
        });

        entities.add({
          position: Cesium.Cartesian3.fromDegrees(-110.0, 35.0),
          ellipse: {
            semiMinorAxis: 100000.0,
            semiMajorAxis: 200000.0,
            height: 300000.0,
            extrudedHeight: 700000.0,
            rotation: Cesium.Math.toRadians(-40.0),
            material: Cesium.Color.fromRandom({ alpha: 1.0 }),
          },
        });

        entities.add({
          polygon: {
            hierarchy: new Cesium.PolygonHierarchy(
              Cesium.Cartesian3.fromDegreesArray([
                -113.0, 30.0, -110.0, 30.0, -110.0, 33.0, -111.5, 31.0, -113.0, 33.0,
              ]),
            ),
            extrudedHeight: 300000.0,
            material: Cesium.Color.fromRandom({ alpha: 1.0 }),
          },
        });

        entities.add({
          position: Cesium.Cartesian3.fromDegrees(-70.0, 40.0, 200000.0),
          cylinder: {
            hierarchy: new Cesium.PolygonHierarchy(
              Cesium.Cartesian3.fromDegreesArray([
                -118.0, 30.0, -115.0, 30.0, -117.1, 31.1, -118.0, 33.0,
              ]),
            ),
            length: 400000.0,
            topRadius: 0.0,
            bottomRadius: 200000.0,
            material: Cesium.Color.fromRandom({ alpha: 1.0 }),
          },
        });

        for (i = 0; i < 5; ++i) {
          height = 200000.0 * i;

          entities.add({
            position: Cesium.Cartesian3.fromDegrees(-65.0, 35.0),
            ellipse: {
              semiMinorAxis: 200000.0,
              semiMajorAxis: 200000.0,
              height: height,
              material: Cesium.Color.fromRandom({ alpha: 0.5 }),
            },
          });

          entities.add({
            rectangle: {
              coordinates: Cesium.Rectangle.fromDegrees(-67.0, 27.0, -63.0, 32.0),
              height: height,
              material: Cesium.Color.fromRandom({ alpha: 0.5 }),
            },
          });
        }

        for (i = 0; i < 5; ++i) {
          height = 100000.0 + 200000.0 * i;
          entities.add({
            position: Cesium.Cartesian3.fromDegrees(-108.0, 45.0, height),
            box: {
              dimensions: new Cesium.Cartesian3(90000.0, 90000.0, 90000.0),
              material: Cesium.Color.fromRandom({ alpha: 1.0 }),
            },
          });

          entities.add({
            position: Cesium.Cartesian3.fromDegrees(-104.0, 45.0, height),
            ellipsoid: {
              radii: new Cesium.Cartesian3(45000.0, 45000.0, 90000.0),
              material: Cesium.Color.fromRandom({ alpha: 1.0 }),
            },
          });

          entities.add({
            position: Cesium.Cartesian3.fromDegrees(-100.0, 45.0, height),
            ellipsoid: {
              radii: new Cesium.Cartesian3(67500.0, 67500.0, 67500.0),
              material: Cesium.Color.fromRandom({ alpha: 1.0 }),
            },
          });
        }

        positions = [];
        for (i = 0; i < 40; ++i) {
          positions.push(Cesium.Cartesian3.fromDegrees(-100.0 + i, 15.0));
        }

        entities.add({
          polyline: {
            positions: positions,
            width: 10.0,
            material: new Cesium.PolylineGlowMaterialProperty({
              color: Cesium.Color.DEEPSKYBLUE,
              glowPower: 0.25,
            }),
          },
        });

        positions = [];
        for (i = 0; i < 40; ++i) {
          positions.push(Cesium.Cartesian3.fromDegrees(-100.0 + i, 9.0));
        }

        entities.add({
          wall: {
            positions: Cesium.Cartesian3.fromDegreesArrayHeights([
              -90.0, 43.0, 100000.0, -87.5, 45.0, 100000.0, -85.0, 43.0, 100000.0,
              -87.5, 41.0, 100000.0, -90.0, 43.0, 100000.0,
            ]),
            material: new Cesium.CheckerboardMaterialProperty({
              repeat: new Cesium.Cartesian2(20.0, 6.0),
            }),
          },
        });

        entities.add({
          corridor: {
            positions: Cesium.Cartesian3.fromDegreesArray([
              -120.0, 45.0, -125.0, 50.0, -125.0, 55.0,
            ]),
            width: 100000,
            material: Cesium.Color.fromRandom({ alpha: 1.0 }),
          },
        });

        entities.add({
          corridor: {
            positions: Cesium.Cartesian3.fromDegreesArray([
              -120.0, 45.0, -125.0, 50.0, -125.0, 55.0,
            ]),
            width: 100000,
            height: 300000,
            extrudedHeight: 400000,
            material: Cesium.Color.fromRandom({ alpha: 0.7 }),
          },
        });

        entities.add({
          corridor: {
            positions: Cesium.Cartesian3.fromDegreesArray([
              -120.0, 45.0, -125.0, 50.0, -125.0, 55.0,
            ]),
            width: 100000,
            height: 700000,
            outline: true,
            outlineColor: Cesium.Color.WHITE,
            outlineWidth: 4,
            material: Cesium.Color.fromRandom({ alpha: 0.7 }),
          },
        });

        function starPositions(arms, rOuter, rInner) {
          const angle = Math.PI / arms;
          const pos = [];
          for (let j = 0; j < 2 * arms; j++) {
            const r = j % 2 === 0 ? rOuter : rInner;
            const p = new Cesium.Cartesian2(
              Math.cos(j * angle) * r,
              Math.sin(j * angle) * r,
            );
            pos.push(p);
          }
          return pos;
        }

        entities.add({
          polylineVolume: {
            positions: Cesium.Cartesian3.fromDegreesArrayHeights([
              -102.0, 15.0, 100000.0, -105.0, 20.0, 200000.0, -110.0, 20.0, 100000.0,
            ]),
            shape: starPositions(7, 30000.0, 20000.0),
            outline: true,
            outlineColor: Cesium.Color.WHITE,
            outlineWidth: 1,
            material: Cesium.Color.fromRandom({ alpha: 1.0 }),
          },
        });

        entities.add({
          polylineVolume: {
            positions: Cesium.Cartesian3.fromDegreesArray([
              -102.0, 15.0, -105.0, 20.0, -110.0, 20.0,
            ]),
            shape: starPositions(7, 30000.0, 20000.0),
            material: Cesium.Color.fromRandom({ alpha: 1.0 }),
          },
        });

        function computeCircle(radius) {
          const circlePositions = [];
          for (let angleDeg = 0; angleDeg < 360; angleDeg++) {
            const radians = Cesium.Math.toRadians(angleDeg);
            circlePositions.push(
              new Cesium.Cartesian2(
                radius * Math.cos(radians),
                radius * Math.sin(radians),
              ),
            );
          }
          return circlePositions;
        }

        entities.add({
          polylineVolume: {
            positions: Cesium.Cartesian3.fromDegreesArray([
              -104.0, 13.0, -107.0, 18.0, -112.0, 18.0,
            ]),
            shape: computeCircle(40000.0),
            material: Cesium.Color.WHITE,
          },
        });

        viewer.zoomTo(viewer.entities);

        viewer.clock.shouldAnimate = false;

        // ==== Meteor: drop-in script integration ====
        // Predetermined cities (extend as needed)
        const CITIES = {
          chicago: { lat: 41.8832, lon: -87.6324 },
        };

        const METEOR = {
          startLon: -99.0,
          startLat: 52.0,
          startAlt: 12000000.0,
          // Select target city (currently only 'chicago')
          targetCity: 'chicago',
          endLon: CITIES.chicago.lon,
          endLat: CITIES.chicago.lat,
          endAlt: 1000.0,
          flightSeconds: 12,
          trailSeconds: 20,
          useModel: false,
          modelUri: "/models/asteroid.glb",
        };

        function makeParticleImage(size = 32) {
          const canvas = document.createElement("canvas");
          canvas.width = size;
          canvas.height = size;
          const ctx = canvas.getContext("2d");
          const gradient = ctx.createRadialGradient(
            size / 2,
            size / 2,
            1,
            size / 2,
            size / 2,
            size / 2
          );
          gradient.addColorStop(0.0, "rgba(255,255,255,1)");
          gradient.addColorStop(0.25, "rgba(255,210,0,0.95)");
          gradient.addColorStop(1.0, "rgba(255,120,0,0)");
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
          ctx.fill();
          return canvas;
        }

        const launchButton = document.getElementById("launchMeteor");
        let meteorActive = false;

        function startMeteorRun() {
          if (!launchButton) {
            console.error("Launch Meteor button is missing.");
            return;
          }
          if (meteorActive) {
            return;
          }

          meteorActive = true;
          launchButton.disabled = true;
          launchButton.textContent = "Meteor in flight";

          const startTime = Cesium.JulianDate.now();
          const stopTime = Cesium.JulianDate.addSeconds(
            startTime,
            METEOR.flightSeconds,
            new Cesium.JulianDate()
          );

          viewer.clock.startTime = startTime.clone();
          viewer.clock.stopTime = stopTime.clone();
          viewer.clock.currentTime = startTime.clone();
          viewer.clock.clockRange = Cesium.ClockRange.CLAMPED;
          viewer.clock.multiplier = 1;
          viewer.clock.shouldAnimate = false;

          const positionProperty = new Cesium.SampledPositionProperty();
          positionProperty.addSample(
            startTime,
            Cesium.Cartesian3.fromDegrees(
              METEOR.startLon,
              METEOR.startLat,
              METEOR.startAlt
            )
          );
          positionProperty.addSample(
            stopTime,
            Cesium.Cartesian3.fromDegrees(
              METEOR.endLon,
              METEOR.endLat,
              METEOR.endAlt
            )
          );

          const baseEntity = {
            position: positionProperty,
            orientation: new Cesium.VelocityOrientationProperty(positionProperty),
            path: {
              resolution: 1,
              leadTime: 0,
              trailTime: METEOR.trailSeconds,
              material: new Cesium.PolylineGlowMaterialProperty({
                color: Cesium.Color.ORANGE,
                glowPower: 0.25,
              }),
              width: 8,
            },
          };

          const meteorEntity = viewer.entities.add(
            METEOR.useModel
              ? {
                  ...baseEntity,
                  model: {
                    uri: METEOR.modelUri,
                    minimumPixelSize: 32,
                    scale: 1.0,
                  },
                }
              : {
                  ...baseEntity,
                  point: {
                    pixelSize: 12,
                    color: Cesium.Color.YELLOW.withAlpha(0.95),
                    outlineColor: Cesium.Color.ORANGE,
                    outlineWidth: 2,
                  },
                }
          );

          const trail = new Cesium.ParticleSystem({
            image: makeParticleImage(32),
            startScale: 1.0,
            endScale: 0.5,
            emissionRate: 140,
            particleLife: 0.6,
            speed: 60.0,
            lifetime: METEOR.flightSeconds + 5,
            emitter: new Cesium.ConeEmitter(Cesium.Math.toRadians(10)),
            sizeInMeters: true,
          });
          viewer.scene.primitives.add(trail);

          let trailRemoved = false;
          const removeTrail = () => {
            if (!trailRemoved) {
              viewer.scene.primitives.remove(trail);
              trailRemoved = true;
            }
          };

          let burstTimeoutId = null;
          let burstPrimitive = null;
          let preRenderCallback;

          const finalize = () => {
            if (burstTimeoutId !== null) {
              window.clearTimeout(burstTimeoutId);
              burstTimeoutId = null;
            }
            viewer.scene.preRender.removeEventListener(preRenderCallback);
            removeTrail();
            if (burstPrimitive) {
              viewer.scene.primitives.remove(burstPrimitive);
              burstPrimitive = null;
            }
            viewer.entities.remove(meteorEntity);
            viewer.clock.shouldAnimate = false;
            meteorActive = false;
            launchButton.disabled = false;
            launchButton.textContent = "Replay Meteor";
          };

          const rotationScratch = new Cesium.Matrix3();
          const flipMatrix = Cesium.Matrix3.fromRotationY(Math.PI, new Cesium.Matrix3());
          const trailMatrix = new Cesium.Matrix4();

          preRenderCallback = function (scene, time) {
            const now = time || viewer.clock.currentTime;
            const position = positionProperty.getValue(now);
            if (!position) {
              return;
            }

            const orientation = meteorEntity.orientation.getValue(now);
            if (orientation) {
              Cesium.Matrix3.fromQuaternion(orientation, rotationScratch);
              Cesium.Matrix3.multiply(rotationScratch, flipMatrix, rotationScratch);
              Cesium.Matrix4.fromRotationTranslation(rotationScratch, position, trailMatrix);
              trail.modelMatrix = trailMatrix;
            } else {
              Cesium.Transforms.eastNorthUpToFixedFrame(
                position,
                undefined,
                trailMatrix
              );
              trail.modelMatrix = trailMatrix;
            }

            const cartographic = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);
            const lowAltitude = cartographic ? cartographic.height < 1500.0 : false;
            const reachedEnd = Cesium.JulianDate.greaterThanOrEquals(now, stopTime);

            if (reachedEnd || lowAltitude) {
              viewer.scene.preRender.removeEventListener(preRenderCallback);

              removeTrail();
              meteorEntity.show = false;

              viewer.clock.currentTime = stopTime.clone();

              const impactCartesian = Cesium.Cartesian3.fromDegrees(
                METEOR.endLon,
                METEOR.endLat,
                10.0
              );
              burstPrimitive = new Cesium.ParticleSystem({
                image: makeParticleImage(48),
                startScale: 2.0,
                endScale: 6.0,
                emissionRate: 0,
                lifetime: 1.6,
                particleLife: 0.8,
                speed: 120.0,
                sizeInMeters: true,
                emitter: new Cesium.SphereEmitter(80.0),
                modelMatrix: Cesium.Transforms.eastNorthUpToFixedFrame(impactCartesian),
                bursts: [
                  new Cesium.ParticleBurst({
                    time: 0.0,
                    minimum: 300,
                    maximum: 300,
                  }),
                ],
              });
              viewer.scene.primitives.add(burstPrimitive);

              burstTimeoutId = window.setTimeout(() => {
                finalize();
              }, 2000);

              if (viewer && viewer.camera) {
                viewer.camera.flyTo({
                  destination: Cesium.Cartesian3.fromDegrees(
                    METEOR.endLon,
                    METEOR.endLat,
                    900000.0
                  ),
                  orientation: { pitch: Cesium.Math.toRadians(-35) },
                  duration: 2.0,
                });
              }
            }
          };

          viewer.scene.preRender.addEventListener(preRenderCallback);

          viewer.clock.shouldAnimate = true;

          // if (viewer && viewer.camera) {
          //   viewer.camera.flyTo({
          //     destination: Cesium.Cartesian3.fromDegrees(
          //       METEOR.startLon,
          //       METEOR.startLat,
          //       1500000.0
          //     ),
          //     orientation: { pitch: Cesium.Math.toRadians(-25) },
          //     duration: 2.0,
          //   });
          // }
        }

        if (launchButton) {
          launchButton.addEventListener("click", startMeteorRun);
        }
      })();
    </script>
  </body>
</html>
